{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/pezannekhambatta/Desktop/resumio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"/Users/pezannekhambatta/Desktop/resumio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Users/pezannekhambatta/Desktop/resumio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"/Users/pezannekhambatta/Desktop/resumio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { isValidElement, useRef, useState, useCallback, useEffect, createContext, useContext, createElement, cloneElement } from 'react';\n\nvar isHTMLElement = value => value instanceof HTMLElement;\n\nconst EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input'\n};\nconst VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  all: 'all'\n};\nconst VALUE = 'value';\nconst SELECT = 'select';\nconst UNDEFINED = 'undefined';\nconst INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate'\n};\n\nfunction attachEventListeners({\n  field: {\n    ref\n  },\n  handleChange,\n  isRadioOrCheckbox\n}) {\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n\nvar isNullOrUndefined = value => value == null;\n\nvar isArray = value => Array.isArray(value);\n\nconst isObjectType = value => typeof value === 'object';\n\nvar isObject = value => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);\n\nvar isKey = value => !isArray(value) && (/^\\w*$/.test(value) || !/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/.test(value));\n\nvar stringToPath = input => {\n  const result = [];\n  input.replace(/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, (match, mathNumber, mathQuote, originalString) => {\n    result.push(mathQuote ? originalString.replace(/\\\\(\\\\)?/g, '$1') : mathNumber || match);\n  });\n  return result;\n};\n\nfunction set(object, path, value) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue = isObject(objValue) || isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nvar transformToNestObject = data => Object.entries(data).reduce((previous, [key, value]) => {\n  if (!isKey(key)) {\n    set(previous, key, value);\n    return previous;\n  }\n\n  return Object.assign(Object.assign({}, previous), {\n    [key]: value\n  });\n}, {});\n\nvar isUndefined = val => val === undefined;\n\nvar unique = value => value.filter(Boolean);\n\nvar get = (obj, path, defaultValue) => {\n  const result = unique(path.split(/[,[\\].]+?/)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], obj);\n  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\n  for (const key in fields) {\n    if (get(fieldErrors, key)) {\n      const field = fields[key];\n\n      if (field) {\n        if (field.ref.focus) {\n          field.ref.focus();\n          break;\n        } else if (field.options) {\n          field.options[0].ref.focus();\n          break;\n        }\n      }\n    }\n  }\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n\nconst defaultReturn = {\n  isValid: false,\n  value: ''\n};\n\nvar getRadioValue = options => isArray(options) ? options.reduce((previous, option) => option && option.ref.checked ? {\n  isValid: true,\n  value: option.ref.value\n} : previous, defaultReturn) : defaultReturn;\n\nvar getMultipleSelectValue = options => [...options].filter(({\n  selected\n}) => selected).map(({\n  value\n}) => value);\n\nvar isRadioInput = element => element.type === 'radio';\n\nvar isFileInput = element => element.type === 'file';\n\nvar isCheckBoxInput = element => element.type === 'checkbox';\n\nvar isMultipleSelect = element => element.type === \"\".concat(SELECT, \"-multiple\");\n\nvar isEmptyString = value => value === '';\n\nconst defaultResult = {\n  value: false,\n  isValid: false\n};\nconst validResult = {\n  value: true,\n  isValid: true\n};\n\nvar getCheckboxValue = options => {\n  if (isArray(options)) {\n    if (options.length > 1) {\n      const values = options.filter(option => option && option.ref.checked).map(({\n        ref: {\n          value\n        }\n      }) => value);\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n\n    const _options$0$ref = options[0].ref,\n          checked = _options$0$ref.checked,\n          value = _options$0$ref.value,\n          attributes = _options$0$ref.attributes;\n    return checked ? attributes && !isUndefined(attributes.value) ? isUndefined(value) || isEmptyString(value) ? validResult : {\n      value: value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n\n  return defaultResult;\n};\n\nfunction getFieldValue(fields, name) {\n  if (fields[name]) {\n    const field = fields[name];\n    const value = field.ref.value,\n          ref = field.ref;\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return field ? getRadioValue(field.options).value : '';\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBoxInput(ref)) {\n      return field ? getCheckboxValue(field.options).value : false;\n    }\n\n    return value;\n  }\n}\n\nfunction isDetached(element) {\n  if (!element) {\n    return true;\n  }\n\n  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) {\n    return false;\n  }\n\n  return isDetached(element.parentNode);\n}\n\nvar isEmptyObject = value => isObject(value) && !Object.keys(value).length;\n\nfunction baseGet(object, updatePath) {\n  const path = updatePath.slice(0, -1);\n  const length = path.length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return index == length ? object : undefined;\n}\n\nfunction unset(object, path) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef = undefined;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef = undefined;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (currentPathsLength === index && (isObject(objectRef) && isEmptyObject(objectRef) || isArray(objectRef) && !objectRef.filter(data => isObject(data) && !isEmptyObject(data)).length)) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\n\nfunction findRemovedFieldAndRemoveListener(fields, handleChange, field, unmountFieldsStateRef, shouldUnregister, forceDelete) {\n  const ref = field.ref,\n        _field$ref = field.ref,\n        name = _field$ref.name,\n        type = _field$ref.type,\n        mutationWatcher = field.mutationWatcher;\n  const fieldRef = fields[name];\n\n  if (!shouldUnregister) {\n    const value = getFieldValue(fields, name);\n\n    if (!isUndefined(value)) {\n      unmountFieldsStateRef.current[name] = value;\n    }\n  }\n\n  if (!type) {\n    delete fields[name];\n    return;\n  }\n\n  if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldRef) {\n    const options = fieldRef.options;\n\n    if (isArray(options) && options.length) {\n      unique(options).forEach((option, index) => {\n        const ref = option.ref,\n              mutationWatcher = option.mutationWatcher;\n\n        if (ref && isDetached(ref) && isSameRef(option, ref) || forceDelete) {\n          removeAllEventListeners(ref, handleChange);\n\n          if (mutationWatcher) {\n            mutationWatcher.disconnect();\n          }\n\n          unset(options, \"[\".concat(index, \"]\"));\n        }\n      });\n\n      if (options && !unique(options).length) {\n        delete fields[name];\n      }\n    } else {\n      delete fields[name];\n    }\n  } else if (isDetached(ref) && isSameRef(fieldRef, ref) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n\n    if (mutationWatcher) {\n      mutationWatcher.disconnect();\n    }\n\n    delete fields[name];\n  }\n}\n\nvar isString = value => typeof value === 'string';\n\nvar getFieldsValues = (fields, search) => {\n  const output = {};\n\n  for (const name in fields) {\n    if (isUndefined(search) || (isString(search) ? name.startsWith(search) : isArray(search) && search.find(data => name.startsWith(data)))) {\n      output[name] = getFieldValue(fields, name);\n    }\n  }\n\n  return output;\n};\n\nvar compareObject = (objectA = {}, objectB = {}) => {\n  const objectAKeys = Object.keys(objectA);\n  return objectAKeys.length === Object.keys(objectB).length && objectAKeys.every(key => objectB[key] && objectB[key] === objectA[key]);\n};\n\nvar isSameError = (error, {\n  type,\n  types,\n  message\n}) => isObject(error) && error.type === type && error.message === message && compareObject(error.types, types);\n\nfunction shouldRenderBasedOnError({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation\n}) {\n  const isFieldValid = isEmptyObject(error);\n  const isFormValid = isEmptyObject(errors);\n  const currentFieldError = get(error, name);\n  const existFieldError = get(errors, name);\n\n  if (isFieldValid && validFields.has(name)) {\n    return false;\n  }\n\n  if (isFormValid !== isFieldValid || !isFormValid && !existFieldError || isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name)) {\n    return true;\n  }\n\n  return currentFieldError && !isSameError(existFieldError, currentFieldError);\n}\n\nvar isRegex = value => value instanceof RegExp;\n\nconst isValueMessage = value => isObject(value) && !isRegex(value);\n\nvar getValueAndMessage = validationData => isValueMessage(validationData) ? validationData : {\n  value: validationData,\n  message: ''\n};\n\nvar isFunction = value => typeof value === 'function';\n\nvar isBoolean = value => typeof value === 'boolean';\n\nvar isMessage = value => isString(value) || isObject(value) && isValidElement(value);\n\nfunction getValidateError(result, ref, type = 'validate') {\n  if (isMessage(result) || isBoolean(result) && !result) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref\n    };\n  }\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\n  if (validateAllFieldCriteria) {\n    const error = errors[name];\n    return Object.assign(Object.assign({}, error), {\n      types: Object.assign(Object.assign({}, error && error.types ? error.types : {}), {\n        [type]: message || true\n      })\n    });\n  }\n\n  return {};\n};\n\nvar validateField = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fieldsRef, validateAllFieldCriteria, {\n    ref,\n    ref: {\n      type,\n      value\n    },\n    options,\n    required,\n    maxLength,\n    minLength,\n    min,\n    max,\n    pattern,\n    validate\n  }) {\n    var _a, fields, name, error, isRadio, isCheckBox, isRadioOrCheckbox, isEmpty, appendErrorsCurry, getMinMaxMessage, _ref2, requiredValue, requiredMessage, exceedMax, exceedMin, _getValueAndMessage, maxValue, maxMessage, _getValueAndMessage2, minValue, minMessage, valueNumber, valueDate, _getValueAndMessage3, maxLengthValue, maxLengthMessage, _getValueAndMessage4, minLengthValue, minLengthMessage, inputLength, _getValueAndMessage5, patternValue, patternMessage, fieldValue, validateRef, result, validateError, validationResult, _i, _Object$entries, _Object$entries$_i, key, validateFunction, validateResult;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          fields = fieldsRef.current;\n          name = ref.name;\n          error = {};\n          isRadio = isRadioInput(ref);\n          isCheckBox = isCheckBoxInput(ref);\n          isRadioOrCheckbox = isRadio || isCheckBox;\n          isEmpty = isEmptyString(value);\n          appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n\n          getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\n            const message = exceedMax ? maxLengthMessage : minLengthMessage;\n            error[name] = Object.assign({\n              type: exceedMax ? maxType : minType,\n              message,\n              ref\n            }, exceedMax ? appendErrorsCurry(maxType, message) : appendErrorsCurry(minType, message));\n          };\n\n          if (!(required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value)) || isBoolean(value) && !value || isCheckBox && !getCheckboxValue(options).isValid || isRadio && !getRadioValue(options).isValid))) {\n            _context.next = 15;\n            break;\n          }\n\n          _ref2 = isMessage(required) ? {\n            value: !!required,\n            message: required\n          } : getValueAndMessage(required), requiredValue = _ref2.value, requiredMessage = _ref2.message;\n\n          if (!requiredValue) {\n            _context.next = 15;\n            break;\n          }\n\n          error[name] = Object.assign({\n            type: INPUT_VALIDATION_RULES.required,\n            message: requiredMessage,\n            ref: isRadioOrCheckbox ? (_a = fields[name].options) === null || _a === void 0 ? void 0 : _a[0].ref : ref\n          }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));\n\n          if (validateAllFieldCriteria) {\n            _context.next = 15;\n            break;\n          }\n\n          return _context.abrupt(\"return\", error);\n\n        case 15:\n          if (!(!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\n            _context.next = 23;\n            break;\n          }\n\n          _getValueAndMessage = getValueAndMessage(max), maxValue = _getValueAndMessage.value, maxMessage = _getValueAndMessage.message;\n          _getValueAndMessage2 = getValueAndMessage(min), minValue = _getValueAndMessage2.value, minMessage = _getValueAndMessage2.message;\n\n          if (type === 'number' || !type && !isNaN(value)) {\n            valueNumber = ref.valueAsNumber || parseFloat(value);\n\n            if (!isNullOrUndefined(maxValue)) {\n              exceedMax = valueNumber > maxValue;\n            }\n\n            if (!isNullOrUndefined(minValue)) {\n              exceedMin = valueNumber < minValue;\n            }\n          } else {\n            valueDate = ref.valueAsDate || new Date(value);\n\n            if (isString(maxValue)) {\n              exceedMax = valueDate > new Date(maxValue);\n            }\n\n            if (isString(minValue)) {\n              exceedMin = valueDate < new Date(minValue);\n            }\n          }\n\n          if (!(exceedMax || exceedMin)) {\n            _context.next = 23;\n            break;\n          }\n\n          getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n\n          if (validateAllFieldCriteria) {\n            _context.next = 23;\n            break;\n          }\n\n          return _context.abrupt(\"return\", error);\n\n        case 23:\n          if (!(isString(value) && !isEmpty && (maxLength || minLength))) {\n            _context.next = 33;\n            break;\n          }\n\n          _getValueAndMessage3 = getValueAndMessage(maxLength), maxLengthValue = _getValueAndMessage3.value, maxLengthMessage = _getValueAndMessage3.message;\n          _getValueAndMessage4 = getValueAndMessage(minLength), minLengthValue = _getValueAndMessage4.value, minLengthMessage = _getValueAndMessage4.message;\n          inputLength = value.toString().length;\n          exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\n          exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\n\n          if (!(exceedMax || exceedMin)) {\n            _context.next = 33;\n            break;\n          }\n\n          getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\n\n          if (validateAllFieldCriteria) {\n            _context.next = 33;\n            break;\n          }\n\n          return _context.abrupt(\"return\", error);\n\n        case 33:\n          if (!(pattern && !isEmpty)) {\n            _context.next = 39;\n            break;\n          }\n\n          _getValueAndMessage5 = getValueAndMessage(pattern), patternValue = _getValueAndMessage5.value, patternMessage = _getValueAndMessage5.message;\n\n          if (!(isRegex(patternValue) && !patternValue.test(value))) {\n            _context.next = 39;\n            break;\n          }\n\n          error[name] = Object.assign({\n            type: INPUT_VALIDATION_RULES.pattern,\n            message: patternMessage,\n            ref\n          }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\n\n          if (validateAllFieldCriteria) {\n            _context.next = 39;\n            break;\n          }\n\n          return _context.abrupt(\"return\", error);\n\n        case 39:\n          if (!validate) {\n            _context.next = 72;\n            break;\n          }\n\n          fieldValue = getFieldValue(fields, name);\n          validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n          if (!isFunction(validate)) {\n            _context.next = 53;\n            break;\n          }\n\n          _context.next = 45;\n          return validate(fieldValue);\n\n        case 45:\n          result = _context.sent;\n          validateError = getValidateError(result, validateRef);\n\n          if (!validateError) {\n            _context.next = 51;\n            break;\n          }\n\n          error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n\n          if (validateAllFieldCriteria) {\n            _context.next = 51;\n            break;\n          }\n\n          return _context.abrupt(\"return\", error);\n\n        case 51:\n          _context.next = 72;\n          break;\n\n        case 53:\n          if (!isObject(validate)) {\n            _context.next = 72;\n            break;\n          }\n\n          validationResult = {};\n          _i = 0, _Object$entries = Object.entries(validate);\n\n        case 56:\n          if (!(_i < _Object$entries.length)) {\n            _context.next = 68;\n            break;\n          }\n\n          _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], validateFunction = _Object$entries$_i[1];\n\n          if (!(!isEmptyObject(validationResult) && !validateAllFieldCriteria)) {\n            _context.next = 60;\n            break;\n          }\n\n          return _context.abrupt(\"break\", 68);\n\n        case 60:\n          _context.next = 62;\n          return validateFunction(fieldValue);\n\n        case 62:\n          validateResult = _context.sent;\n          validateError = getValidateError(validateResult, validateRef, key);\n\n          if (validateError) {\n            validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\n\n            if (validateAllFieldCriteria) {\n              error[name] = validationResult;\n            }\n          }\n\n        case 65:\n          _i++;\n          _context.next = 56;\n          break;\n\n        case 68:\n          if (isEmptyObject(validationResult)) {\n            _context.next = 72;\n            break;\n          }\n\n          error[name] = Object.assign({\n            ref: validateRef\n          }, validationResult);\n\n          if (validateAllFieldCriteria) {\n            _context.next = 72;\n            break;\n          }\n\n          return _context.abrupt(\"return\", error);\n\n        case 72:\n          return _context.abrupt(\"return\", error);\n\n        case 73:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n\n  return function validateField(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar isPrimitive = value => isNullOrUndefined(value) || !isObjectType(value);\n\nconst getPath = (path, values) => {\n  const getInnerPath = (value, key, isObject) => {\n    const pathWithIndex = isObject ? \"\".concat(path, \".\").concat(key) : \"\".concat(path, \"[\").concat(key, \"]\");\n    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\n  };\n\n  return isArray(values) ? values.map((value, key) => getInnerPath(value, key)) : Object.entries(values).map(([key, value]) => getInnerPath(value, key, true));\n};\n\nvar getPath$1 = (parentPath, value) => getPath(parentPath, value).flat(Infinity);\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\n  let value;\n  watchFields.add(fieldName);\n\n  if (isEmptyObject(fieldValues)) {\n    value = undefined;\n  } else if (!isUndefined(fieldValues[fieldName])) {\n    value = fieldValues[fieldName];\n  } else {\n    value = get(transformToNestObject(fieldValues), fieldName);\n\n    if (!isUndefined(value)) {\n      getPath$1(fieldName, value).forEach(name => watchFields.add(name));\n    }\n  }\n\n  return isUndefined(value) ? isSingleField ? inputValue : get(inputValue, fieldName) : value;\n};\n\nvar skipValidation = ({\n  isOnChange,\n  hasError,\n  isBlurEvent,\n  isOnSubmit,\n  isReValidateOnSubmit,\n  isOnBlur,\n  isReValidateOnBlur,\n  isSubmitted\n}) => isOnChange && isBlurEvent || isOnSubmit && isReValidateOnSubmit || isOnSubmit && !isSubmitted || isOnBlur && !isBlurEvent && !hasError || isReValidateOnBlur && !isBlurEvent && hasError || isReValidateOnSubmit && isSubmitted;\n\nvar getFieldArrayParentName = name => name.substring(0, name.indexOf('['));\n\nvar getFieldValueByName = (fields, name) => {\n  const results = transformToNestObject(getFieldsValues(fields));\n  return name ? get(results, name, results) : results;\n};\n\nfunction getIsFieldsDifferent(referenceArray, differenceArray) {\n  if (!isArray(referenceArray) || !isArray(differenceArray) || referenceArray.length !== differenceArray.length) {\n    return true;\n  }\n\n  for (let i = 0; i < referenceArray.length; i++) {\n    const dataA = referenceArray[i];\n    const dataB = differenceArray[i];\n\n    if (isUndefined(dataB) || Object.keys(dataA).length !== Object.keys(dataB).length) {\n      return true;\n    }\n\n    for (const key in dataA) {\n      if (dataA[key] !== dataB[key]) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(\"^\".concat(searchName, \"[\\\\d+]\").replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\n\nvar isNameInFieldArray = (names, name) => [...names].some(current => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = element => element.type === \"\".concat(SELECT, \"-one\");\n\nfunction onDomRemove(element, onDetachCallback) {\n  const observer = new MutationObserver(() => {\n    if (isDetached(element)) {\n      observer.disconnect();\n      onDetachCallback();\n    }\n  });\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nvar modeChecker = mode => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all\n});\n\nvar isRadioOrCheckboxFunction = ref => isRadioInput(ref) || isCheckBoxInput(ref);\n\nfunction useForm({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {},\n  shouldFocusError = true,\n  shouldUnregister = true,\n  criteriaMode\n} = {}) {\n  const fieldsRef = useRef({});\n  const errorsRef = useRef({});\n  const touchedFieldsRef = useRef({});\n  const fieldArrayDefaultValues = useRef({});\n  const watchFieldsRef = useRef(new Set());\n  const dirtyFieldsRef = useRef({});\n  const watchFieldsHookRef = useRef({});\n  const watchFieldsHookRenderRef = useRef({});\n  const fieldsWithValidationRef = useRef(new Set());\n  const validFieldsRef = useRef(new Set());\n  const isValidRef = useRef(true);\n  const defaultValuesRef = useRef(defaultValues);\n  const defaultValuesAtRenderRef = useRef({});\n  const isUnMount = useRef(false);\n  const isWatchAllRef = useRef(false);\n  const isSubmittedRef = useRef(false);\n  const isDirtyRef = useRef(false);\n  const submitCountRef = useRef(0);\n  const isSubmittingRef = useRef(false);\n  const handleChangeRef = useRef();\n  const unmountFieldsStateRef = useRef({});\n  const resetFieldArrayFunctionRef = useRef({});\n  const contextRef = useRef(context);\n  const resolverRef = useRef(resolver);\n  const fieldArrayNamesRef = useRef(new Set());\n\n  const _useState = useState(),\n        _useState2 = _slicedToArray(_useState, 2),\n        render = _useState2[1];\n\n  const _useRef$current = useRef(modeChecker(mode)).current,\n        isOnBlur = _useRef$current.isOnBlur,\n        isOnSubmit = _useRef$current.isOnSubmit,\n        isOnChange = _useRef$current.isOnChange,\n        isOnAll = _useRef$current.isOnAll;\n  const validateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const isWindowUndefined = typeof window === UNDEFINED;\n  const isWeb = typeof document !== UNDEFINED && !isWindowUndefined && !isUndefined(window.HTMLElement);\n  const isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n  const readFormStateRef = useRef({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    isSubmitted: isOnSubmit,\n    submitCount: !isProxyEnabled,\n    touched: !isProxyEnabled,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled\n  });\n  const _useRef$current2 = useRef(modeChecker(reValidateMode)).current,\n        isReValidateOnBlur = _useRef$current2.isOnBlur,\n        isReValidateOnSubmit = _useRef$current2.isOnSubmit;\n  contextRef.current = context;\n  resolverRef.current = resolver;\n  const reRender = useCallback(() => {\n    if (!isUnMount.current) {\n      render({});\n    }\n  }, []);\n  const shouldRenderBaseOnError = useCallback((name, error, shouldRender = false) => {\n    let shouldReRender = shouldRender || shouldRenderBasedOnError({\n      errors: errorsRef.current,\n      error,\n      name,\n      validFields: validFieldsRef.current,\n      fieldsWithValidation: fieldsWithValidationRef.current\n    });\n    const previousError = get(errorsRef.current, name);\n\n    if (isEmptyObject(error)) {\n      if (fieldsWithValidationRef.current.has(name) || resolverRef.current) {\n        validFieldsRef.current.add(name);\n        shouldReRender = shouldReRender || previousError;\n      }\n\n      errorsRef.current = unset(errorsRef.current, name);\n    } else {\n      validFieldsRef.current.delete(name);\n      shouldReRender = shouldReRender || !previousError || !isSameError(previousError, error[name]);\n      set(errorsRef.current, name, error[name]);\n    }\n\n    if (shouldReRender && !isNullOrUndefined(shouldRender)) {\n      reRender();\n      return true;\n    }\n  }, [reRender, resolverRef]);\n  const setFieldValue = useCallback(({\n    ref,\n    options\n  }, rawValue) => {\n    const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue) ? '' : rawValue;\n\n    if (isRadioInput(ref) && options) {\n      options.forEach(({\n        ref: radioRef\n      }) => radioRef.checked = radioRef.value === value);\n    } else if (isFileInput(ref)) {\n      if (isString(value)) {\n        ref.value = value;\n      } else {\n        ref.files = value;\n      }\n    } else if (isMultipleSelect(ref)) {\n      [...ref.options].forEach(selectRef => selectRef.selected = value.includes(selectRef.value));\n    } else if (isCheckBoxInput(ref) && options) {\n      options.length > 1 ? options.forEach(({\n        ref: checkboxRef\n      }) => checkboxRef.checked = value.includes(checkboxRef.value)) : options[0].ref.checked = !!value;\n    } else {\n      ref.value = value;\n    }\n  }, [isWeb]);\n  const setDirty = useCallback(name => {\n    const _readFormStateRef$cur = readFormStateRef.current,\n          isDirty = _readFormStateRef$cur.isDirty,\n          dirtyFields = _readFormStateRef$cur.dirtyFields;\n\n    if (!fieldsRef.current[name] || !isDirty && !dirtyFields) {\n      return false;\n    }\n\n    const isFieldDirty = defaultValuesAtRenderRef.current[name] !== getFieldValue(fieldsRef.current, name);\n    const isDirtyFieldExist = get(dirtyFieldsRef.current, name);\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n    const previousIsDirty = isDirtyRef.current;\n\n    if (isFieldDirty) {\n      set(dirtyFieldsRef.current, name, true);\n    } else {\n      unset(dirtyFieldsRef.current, name);\n    }\n\n    isDirtyRef.current = isFieldArray && getIsFieldsDifferent(getFieldValueByName(fieldsRef.current, getFieldArrayParentName(name)), get(defaultValuesRef.current, getFieldArrayParentName(name))) || !isEmptyObject(dirtyFieldsRef.current);\n    return isDirty && previousIsDirty !== isDirtyRef.current || dirtyFields && isDirtyFieldExist !== get(dirtyFieldsRef.current, name);\n  }, []);\n  const executeValidation = useCallback( /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(name, skipReRender) {\n      var error;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!fieldsRef.current[name]) {\n              _context2.next = 6;\n              break;\n            }\n\n            _context2.next = 3;\n            return validateField(fieldsRef, validateAllFieldCriteria, fieldsRef.current[name]);\n\n          case 3:\n            error = _context2.sent;\n            shouldRenderBaseOnError(name, error, skipReRender ? null : false);\n            return _context2.abrupt(\"return\", isEmptyObject(error));\n\n          case 6:\n            return _context2.abrupt(\"return\", false);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n\n    return function (_x4, _x5) {\n      return _ref3.apply(this, arguments);\n    };\n  }(), [shouldRenderBaseOnError, validateAllFieldCriteria]);\n  const executeSchemaOrResolverValidation = useCallback( /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(payload) {\n      var _yield$resolverRef$cu, errors, previousFormIsValid, isInputsValid, error;\n\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return resolverRef.current(getFieldValueByName(fieldsRef.current), contextRef.current, validateAllFieldCriteria);\n\n          case 2:\n            _yield$resolverRef$cu = _context3.sent;\n            errors = _yield$resolverRef$cu.errors;\n            previousFormIsValid = isValidRef.current;\n            isValidRef.current = isEmptyObject(errors);\n\n            if (!isArray(payload)) {\n              _context3.next = 12;\n              break;\n            }\n\n            isInputsValid = payload.map(name => {\n              const error = get(errors, name);\n\n              if (error) {\n                set(errorsRef.current, name, error);\n              } else {\n                unset(errorsRef.current, name);\n              }\n\n              return !error;\n            }).every(Boolean);\n            reRender();\n            return _context3.abrupt(\"return\", isInputsValid);\n\n          case 12:\n            error = get(errors, payload);\n            shouldRenderBaseOnError(payload, error ? {\n              [payload]: error\n            } : {}, previousFormIsValid !== isValidRef.current);\n            return _context3.abrupt(\"return\", !error);\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }));\n\n    return function (_x6) {\n      return _ref4.apply(this, arguments);\n    };\n  }(), [reRender, shouldRenderBaseOnError, validateAllFieldCriteria, resolverRef]);\n  const trigger = useCallback( /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(name) {\n      var fields, result;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            fields = name || Object.keys(fieldsRef.current);\n\n            if (!resolverRef.current) {\n              _context5.next = 3;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", executeSchemaOrResolverValidation(fields));\n\n          case 3:\n            if (!isArray(fields)) {\n              _context5.next = 9;\n              break;\n            }\n\n            _context5.next = 6;\n            return Promise.all(fields.map( /*#__PURE__*/function () {\n              var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(data) {\n                return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                  while (1) switch (_context4.prev = _context4.next) {\n                    case 0:\n                      _context4.next = 2;\n                      return executeValidation(data, true);\n\n                    case 2:\n                      return _context4.abrupt(\"return\", _context4.sent);\n\n                    case 3:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }, _callee4);\n              }));\n\n              return function (_x8) {\n                return _ref6.apply(this, arguments);\n              };\n            }()));\n\n          case 6:\n            result = _context5.sent;\n            reRender();\n            return _context5.abrupt(\"return\", result.every(Boolean));\n\n          case 9:\n            _context5.next = 11;\n            return executeValidation(fields);\n\n          case 11:\n            return _context5.abrupt(\"return\", _context5.sent);\n\n          case 12:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }));\n\n    return function (_x7) {\n      return _ref5.apply(this, arguments);\n    };\n  }(), [executeSchemaOrResolverValidation, executeValidation, reRender, resolverRef]);\n  const setInternalValues = useCallback((name, value, config, parentFieldName) => {\n    for (const key in value) {\n      const fieldName = \"\".concat(parentFieldName || name).concat(isArray(value) ? \"[\".concat(key, \"]\") : \".\".concat(key));\n      const field = fieldsRef.current[fieldName];\n\n      if (isObject(value[key])) {\n        setInternalValues(name, value[key], config, fieldName);\n      }\n\n      if (field) {\n        setFieldValue(field, value[key]);\n\n        if (config.shouldDirty) {\n          setDirty(fieldName);\n        }\n\n        if (config.shouldValidate) {\n          trigger(fieldName);\n        }\n      }\n    }\n  }, [trigger, setFieldValue, setDirty]);\n  const setInternalValue = useCallback((name, value, config) => {\n    if (fieldsRef.current[name]) {\n      setFieldValue(fieldsRef.current[name], value);\n      return config.shouldDirty && setDirty(name);\n    } else if (!isPrimitive(value)) {\n      setInternalValues(name, value, config);\n    }\n  }, [setDirty, setFieldValue, setInternalValues]);\n\n  const isFieldWatched = name => isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const renderWatchedInputs = (name, found = true) => {\n    if (!isEmptyObject(watchFieldsHookRef.current)) {\n      for (const key in watchFieldsHookRef.current) {\n        if (watchFieldsHookRef.current[key].has(name) || !watchFieldsHookRef.current[key].size || isNameInFieldArray(fieldArrayNamesRef.current, name)) {\n          watchFieldsHookRenderRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue(name, value, config = {}) {\n    const shouldRender = setInternalValue(name, value, config) || !isPrimitive(value) || isFieldWatched(name);\n    renderWatchedInputs(name);\n\n    if (shouldRender) {\n      reRender();\n    }\n\n    if (config.shouldValidate) {\n      trigger(name);\n    }\n  }\n\n  handleChangeRef.current = handleChangeRef.current ? handleChangeRef.current : /*#__PURE__*/function () {\n    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6({\n      type,\n      target\n    }) {\n      var name, field, error, isBlurEvent, shouldSkipValidation, shouldRender, _yield$resolver, errors, previousFormIsValid;\n\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            name = target ? target.name : '';\n            field = fieldsRef.current[name];\n\n            if (field) {\n              _context6.next = 4;\n              break;\n            }\n\n            return _context6.abrupt(\"return\");\n\n          case 4:\n            isBlurEvent = type === EVENTS.BLUR;\n            shouldSkipValidation = !isOnAll && skipValidation({\n              hasError: !!get(errorsRef.current, name),\n              isOnChange,\n              isBlurEvent,\n              isOnSubmit,\n              isReValidateOnSubmit,\n              isOnBlur,\n              isReValidateOnBlur,\n              isSubmitted: isSubmittedRef.current\n            });\n            shouldRender = setDirty(name) || isFieldWatched(name);\n\n            if (isBlurEvent && !get(touchedFieldsRef.current, name) && readFormStateRef.current.touched) {\n              set(touchedFieldsRef.current, name, true);\n              shouldRender = true;\n            }\n\n            if (!shouldSkipValidation) {\n              _context6.next = 11;\n              break;\n            }\n\n            renderWatchedInputs(name);\n            return _context6.abrupt(\"return\", shouldRender && reRender());\n\n          case 11:\n            if (!resolver) {\n              _context6.next = 22;\n              break;\n            }\n\n            _context6.next = 14;\n            return resolver(getFieldValueByName(fieldsRef.current), contextRef.current, validateAllFieldCriteria);\n\n          case 14:\n            _yield$resolver = _context6.sent;\n            errors = _yield$resolver.errors;\n            previousFormIsValid = isValidRef.current;\n            isValidRef.current = isEmptyObject(errors);\n            error = get(errors, name) ? {\n              [name]: get(errors, name)\n            } : {};\n\n            if (previousFormIsValid !== isValidRef.current) {\n              shouldRender = true;\n            }\n\n            _context6.next = 25;\n            break;\n\n          case 22:\n            _context6.next = 24;\n            return validateField(fieldsRef, validateAllFieldCriteria, field);\n\n          case 24:\n            error = _context6.sent;\n\n          case 25:\n            renderWatchedInputs(name);\n\n            if (!shouldRenderBaseOnError(name, error) && shouldRender) {\n              reRender();\n            }\n\n          case 27:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, _callee6);\n    }));\n\n    return function (_x9) {\n      return _ref7.apply(this, arguments);\n    };\n  }();\n  const validateResolver = useCallback((values = {}) => {\n    const fieldValues = isEmptyObject(defaultValuesRef.current) ? getFieldsValues(fieldsRef.current) : defaultValuesRef.current;\n    resolverRef.current(transformToNestObject(Object.assign(Object.assign({}, fieldValues), values)), contextRef.current, validateAllFieldCriteria).then(({\n      errors\n    }) => {\n      const previousFormIsValid = isValidRef.current;\n      isValidRef.current = isEmptyObject(errors);\n\n      if (previousFormIsValid !== isValidRef.current) {\n        reRender();\n      }\n    });\n  }, [reRender, validateAllFieldCriteria, resolverRef]);\n  const removeFieldEventListener = useCallback((field, forceDelete) => {\n    findRemovedFieldAndRemoveListener(fieldsRef.current, handleChangeRef.current, field, unmountFieldsStateRef, shouldUnregister, forceDelete);\n  }, [shouldUnregister]);\n  const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\n    if (field && (!isNameInFieldArray(fieldArrayNamesRef.current, field.ref.name) || forceDelete)) {\n      removeFieldEventListener(field, forceDelete);\n\n      if (shouldUnregister) {\n        [errorsRef, touchedFieldsRef, dirtyFieldsRef, defaultValuesAtRenderRef].forEach(data => unset(data.current, field.ref.name));\n        [fieldsWithValidationRef, validFieldsRef, watchFieldsRef].forEach(data => data.current.delete(field.ref.name));\n\n        if (readFormStateRef.current.isValid || readFormStateRef.current.touched) {\n          reRender();\n\n          if (resolverRef.current) {\n            validateResolver();\n          }\n        }\n      }\n    }\n  }, [reRender, validateResolver, removeFieldEventListener, resolverRef]);\n\n  function clearErrors(name) {\n    if (name) {\n      (isArray(name) ? name : [name]).forEach(inputName => unset(errorsRef.current, inputName));\n    } else {\n      errorsRef.current = {};\n    }\n\n    reRender();\n  }\n\n  function setError(name, error) {\n    isValidRef.current = false;\n    set(errorsRef.current, name, Object.assign(Object.assign({}, error), {\n      ref: (fieldsRef.current[name] || {}).ref\n    }));\n    reRender();\n  }\n\n  const watchInternal = useCallback((fieldNames, defaultValue, watchId) => {\n    const watchFields = watchId ? watchFieldsHookRef.current[watchId] : watchFieldsRef.current;\n    const combinedDefaultValues = isUndefined(defaultValue) ? defaultValuesRef.current : defaultValue;\n    const fieldValues = getFieldsValues(fieldsRef.current, fieldNames);\n\n    if (isString(fieldNames)) {\n      return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(defaultValue) ? get(combinedDefaultValues, fieldNames) : defaultValue, true);\n    }\n\n    if (isArray(fieldNames)) {\n      return fieldNames.reduce((previous, name) => Object.assign(Object.assign({}, previous), {\n        [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues)\n      }), {});\n    }\n\n    if (isUndefined(watchId)) {\n      isWatchAllRef.current = true;\n    }\n\n    return transformToNestObject(!isEmptyObject(fieldValues) && fieldValues || combinedDefaultValues);\n  }, []);\n\n  function watch(fieldNames, defaultValue) {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(name) {\n    (isArray(name) ? name : [name]).forEach(fieldName => removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true));\n  }\n\n  function registerFieldsRef(ref, validateOptions = {}) {\n    if (!ref.name) {\n      // eslint-disable-next-line no-console\n      return console.warn('Missing name @', ref);\n    }\n\n    const name = ref.name,\n          type = ref.type,\n          value = ref.value;\n    const fieldRefAndValidationOptions = Object.assign({\n      ref\n    }, validateOptions);\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n    let field = fields[name];\n    let isEmptyDefaultValue = true;\n    let isFieldArray;\n    let defaultValue;\n\n    if (field && (isRadioOrCheckbox ? isArray(field.options) && unique(field.options).find(option => {\n      return value === option.ref.value && option.ref === ref;\n    }) : ref === field.ref)) {\n      fields[name] = Object.assign(Object.assign({}, field), validateOptions);\n      return;\n    }\n\n    if (type) {\n      const mutationWatcher = onDomRemove(ref, () => removeFieldEventListenerAndRef(field));\n      field = isRadioOrCheckbox ? Object.assign({\n        options: [...unique(field && field.options || []), {\n          ref,\n          mutationWatcher\n        }],\n        ref: {\n          type,\n          name\n        }\n      }, validateOptions) : Object.assign(Object.assign({}, fieldRefAndValidationOptions), {\n        mutationWatcher\n      });\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n    const isEmptyUnmountFields = isUndefined(unmountFieldsStateRef.current[name]);\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = isEmptyUnmountFields ? get(defaultValuesRef.current, name) : unmountFieldsStateRef.current[name];\n      isEmptyDefaultValue = isUndefined(defaultValue);\n      isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(field, defaultValue);\n      }\n    }\n\n    if (resolver && !isFieldArray && readFormStateRef.current.isValid) {\n      validateResolver();\n    } else if (!isEmptyObject(validateOptions)) {\n      fieldsWithValidationRef.current.add(name);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(fieldsRef, validateAllFieldCriteria, field).then(error => {\n          const previousFormIsValid = isValidRef.current;\n          isEmptyObject(error) ? validFieldsRef.current.add(name) : isValidRef.current = false;\n\n          if (previousFormIsValid !== isValidRef.current) {\n            reRender();\n          }\n        });\n      }\n    }\n\n    if (!defaultValuesAtRenderRef.current[name] && !(isFieldArray && isEmptyDefaultValue)) {\n      defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue ? getFieldValue(fields, name) : defaultValue;\n    }\n\n    if (type) {\n      attachEventListeners({\n        field: isRadioOrCheckbox && field.options ? field.options[field.options.length - 1] : field,\n        isRadioOrCheckbox: isRadioOrCheckbox || isSelectInput(ref),\n        handleChange: handleChangeRef.current\n      });\n    }\n  }\n\n  function register(refOrValidationOptions, rules) {\n    if (!isWindowUndefined) {\n      if (isString(refOrValidationOptions)) {\n        registerFieldsRef({\n          name: refOrValidationOptions\n        }, rules);\n      } else if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {\n        registerFieldsRef(refOrValidationOptions, rules);\n      } else {\n        return ref => ref && registerFieldsRef(ref, refOrValidationOptions);\n      }\n    }\n  }\n\n  const handleSubmit = useCallback(callback => /*#__PURE__*/function () {\n    var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(e) {\n      var fieldErrors, fieldValues, _yield$resolverRef$cu2, errors, values, _i2, _Object$values, field, name, fieldError;\n\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            if (e) {\n              e.preventDefault();\n              e.persist();\n            }\n\n            fieldErrors = {};\n            fieldValues = Object.assign(Object.assign({}, unmountFieldsStateRef.current), getFieldsValues(fieldsRef.current));\n\n            if (readFormStateRef.current.isSubmitting) {\n              isSubmittingRef.current = true;\n              reRender();\n            }\n\n            _context7.prev = 4;\n\n            if (!resolverRef.current) {\n              _context7.next = 16;\n              break;\n            }\n\n            _context7.next = 8;\n            return resolverRef.current(transformToNestObject(fieldValues), contextRef.current, validateAllFieldCriteria);\n\n          case 8:\n            _yield$resolverRef$cu2 = _context7.sent;\n            errors = _yield$resolverRef$cu2.errors;\n            values = _yield$resolverRef$cu2.values;\n            errorsRef.current = errors;\n            fieldErrors = errors;\n            fieldValues = values;\n            _context7.next = 28;\n            break;\n\n          case 16:\n            _i2 = 0, _Object$values = Object.values(fieldsRef.current);\n\n          case 17:\n            if (!(_i2 < _Object$values.length)) {\n              _context7.next = 28;\n              break;\n            }\n\n            field = _Object$values[_i2];\n\n            if (!field) {\n              _context7.next = 25;\n              break;\n            }\n\n            name = field.ref.name;\n            _context7.next = 23;\n            return validateField(fieldsRef, validateAllFieldCriteria, field);\n\n          case 23:\n            fieldError = _context7.sent;\n\n            if (fieldError[name]) {\n              set(fieldErrors, name, fieldError[name]);\n              validFieldsRef.current.delete(name);\n            } else if (fieldsWithValidationRef.current.has(name)) {\n              validFieldsRef.current.add(name);\n            }\n\n          case 25:\n            _i2++;\n            _context7.next = 17;\n            break;\n\n          case 28:\n            if (!(isEmptyObject(fieldErrors) && Object.keys(errorsRef.current).every(name => Object.keys(fieldsRef.current).includes(name)))) {\n              _context7.next = 35;\n              break;\n            }\n\n            errorsRef.current = {};\n            reRender();\n            _context7.next = 33;\n            return callback(transformToNestObject(fieldValues), e);\n\n          case 33:\n            _context7.next = 37;\n            break;\n\n          case 35:\n            errorsRef.current = Object.assign(Object.assign({}, errorsRef.current), fieldErrors);\n\n            if (shouldFocusError && isWeb) {\n              focusOnErrorField(fieldsRef.current, fieldErrors);\n            }\n\n          case 37:\n            _context7.prev = 37;\n            isSubmittedRef.current = true;\n            isSubmittingRef.current = false;\n            submitCountRef.current = submitCountRef.current + 1;\n            reRender();\n            return _context7.finish(37);\n\n          case 43:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _callee7, null, [[4,, 37, 43]]);\n    }));\n\n    return function (_x10) {\n      return _ref8.apply(this, arguments);\n    };\n  }(), [isWeb, reRender, resolverRef, shouldFocusError, validateAllFieldCriteria]);\n\n  const resetRefs = ({\n    errors,\n    isDirty,\n    isSubmitted,\n    touched,\n    isValid,\n    submitCount,\n    dirtyFields\n  }) => {\n    fieldsRef.current = {};\n\n    if (!errors) {\n      errorsRef.current = {};\n    }\n\n    if (!touched) {\n      touchedFieldsRef.current = {};\n    }\n\n    if (!isValid) {\n      validFieldsRef.current = new Set();\n      fieldsWithValidationRef.current = new Set();\n      isValidRef.current = true;\n    }\n\n    if (!isDirty) {\n      isDirtyRef.current = false;\n    }\n\n    if (!dirtyFields) {\n      dirtyFieldsRef.current = {};\n    }\n\n    if (!isSubmitted) {\n      isSubmittedRef.current = false;\n    }\n\n    if (!submitCount) {\n      submitCountRef.current = 0;\n    }\n\n    defaultValuesAtRenderRef.current = {};\n    fieldArrayDefaultValues.current = {};\n    unmountFieldsStateRef.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n  };\n\n  const reset = (values, omitResetState = {}) => {\n    if (isWeb) {\n      for (var _i3 = 0, _Object$values2 = Object.values(fieldsRef.current); _i3 < _Object$values2.length; _i3++) {\n        const field = _Object$values2[_i3];\n\n        if (field) {\n          const ref = field.ref,\n                options = field.options;\n          const inputRef = isRadioOrCheckboxFunction(ref) && isArray(options) ? options[0].ref : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form').reset();\n              break;\n            } catch (_a) {}\n          }\n        }\n      }\n    }\n\n    if (values) {\n      defaultValuesRef.current = values;\n    }\n\n    Object.values(resetFieldArrayFunctionRef.current).forEach(resetFieldArray => isFunction(resetFieldArray) && resetFieldArray());\n    resetRefs(omitResetState);\n    reRender();\n  };\n\n  const getValue = name => getFieldValue(fieldsRef.current, name);\n\n  function getValues(payload) {\n    const fields = fieldsRef.current;\n\n    if (isString(payload)) {\n      return getValue(payload);\n    }\n\n    if (isArray(payload)) {\n      return payload.reduce((previous, name) => Object.assign(Object.assign({}, previous), {\n        [name]: getValue(name)\n      }), {});\n    }\n\n    return transformToNestObject(getFieldsValues(fields));\n  }\n\n  useEffect(() => {\n    isUnMount.current = false;\n    return () => {\n      isUnMount.current = true;\n      fieldsRef.current && process.env.NODE_ENV === 'production' && Object.values(fieldsRef.current).forEach(field => removeFieldEventListenerAndRef(field, true));\n    };\n  }, [removeFieldEventListenerAndRef]);\n\n  if (!resolver) {\n    isValidRef.current = validFieldsRef.current.size >= fieldsWithValidationRef.current.size && isEmptyObject(errorsRef.current);\n  }\n\n  const formState = {\n    dirtyFields: dirtyFieldsRef.current,\n    isSubmitted: isSubmittedRef.current,\n    submitCount: submitCountRef.current,\n    touched: touchedFieldsRef.current,\n    isDirty: isDirtyRef.current,\n    isSubmitting: isSubmittingRef.current,\n    isValid: isOnSubmit ? isSubmittedRef.current && isEmptyObject(errorsRef.current) : isValidRef.current\n  };\n  const commonProps = {\n    trigger,\n    setValue: useCallback(setValue, [reRender, setInternalValue, trigger]),\n    getValues: useCallback(getValues, []),\n    register: useCallback(register, [defaultValuesRef.current]),\n    unregister: useCallback(unregister, []),\n    formState: isProxyEnabled ? new Proxy(formState, {\n      get: (obj, prop) => {\n        if (prop in obj) {\n          readFormStateRef.current[prop] = true;\n          return obj[prop];\n        }\n\n        return undefined;\n      }\n    }) : formState\n  };\n  const control = Object.assign(Object.assign(Object.assign({\n    removeFieldEventListener,\n    renderWatchedInputs,\n    watchInternal,\n    reRender\n  }, resolver ? {\n    validateSchemaIsValid: validateResolver\n  } : {}), {\n    mode: {\n      isOnBlur,\n      isOnSubmit,\n      isOnChange\n    },\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnSubmit\n    },\n    errorsRef,\n    touchedFieldsRef,\n    fieldsRef,\n    isWatchAllRef,\n    watchFieldsRef,\n    resetFieldArrayFunctionRef,\n    watchFieldsHookRef,\n    watchFieldsHookRenderRef,\n    fieldArrayDefaultValues,\n    validFieldsRef,\n    dirtyFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayNamesRef,\n    isDirtyRef,\n    isSubmittedRef,\n    readFormStateRef,\n    defaultValuesRef,\n    unmountFieldsStateRef\n  }), commonProps);\n  return Object.assign({\n    watch,\n    control,\n    handleSubmit,\n    reset: useCallback(reset, []),\n    clearErrors: useCallback(clearErrors, []),\n    setError: useCallback(setError, []),\n    errors: errorsRef.current\n  }, commonProps);\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nconst FormContext = createContext(null);\nFormContext.displayName = 'RHFContext';\n\nconst useFormContext = () => useContext(FormContext);\n\nconst FormProvider = _a => {\n  var children = _a.children,\n      props = __rest(_a, [\"children\"]);\n\n  return createElement(FormContext.Provider, {\n    value: Object.assign({}, props)\n  }, children);\n};\n\nvar generateId = () => {\n  const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n};\n\nconst appendId = (value, keyName) => Object.assign({\n  [keyName]: generateId()\n}, isObject(value) ? value : {\n  value\n});\n\nconst mapIds = (data, keyName) => (isArray(data) ? data : []).map(value => appendId(value, keyName));\n\nconst removeAt = (data, index) => [...data.slice(0, index), ...data.slice(index + 1)];\n\nfunction removeAtIndexes(data, index) {\n  let k = -1;\n\n  while (++k < data.length) {\n    if (index.indexOf(k) >= 0) {\n      delete data[k];\n    }\n  }\n\n  return unique(data);\n}\n\nvar removeArrayAt = (data, index) => isUndefined(index) ? [] : isArray(index) ? removeAtIndexes(data, index) : removeAt(data, index);\n\nvar moveArrayAt = (data, from, to) => isArray(data) ? data.splice(to, 0, data.splice(from, 1)[0]) : [];\n\nvar swapArrayAt = (data, indexA, indexB) => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n\nfunction prepend(data, value) {\n  return [...(isArray(value) ? value : [value || null]), ...data];\n}\n\nfunction insert(data, index, value) {\n  return [...data.slice(0, index), ...(isArray(value) ? value : [value || null]), ...data.slice(index)];\n}\n\nvar fillEmptyArray = value => isArray(value) ? Array(value.length).fill(null) : null;\n\nfunction mapValueToBoolean(value) {\n  if (isObject(value)) {\n    const object = {};\n\n    for (const key in value) {\n      object[key] = true;\n    }\n\n    return [object];\n  }\n\n  return [true];\n}\n\nconst filterBooleanArray = value => isArray(value) ? value.map(mapValueToBoolean).flat() : mapValueToBoolean(value);\n\nconst useFieldArray = ({\n  control,\n  name,\n  keyName = 'id'\n}) => {\n  const methods = useFormContext();\n  const focusIndexRef = useRef(-1);\n\n  const _ref9 = control || methods.control,\n        isWatchAllRef = _ref9.isWatchAllRef,\n        resetFieldArrayFunctionRef = _ref9.resetFieldArrayFunctionRef,\n        fieldArrayNamesRef = _ref9.fieldArrayNamesRef,\n        reRender = _ref9.reRender,\n        fieldsRef = _ref9.fieldsRef,\n        defaultValuesRef = _ref9.defaultValuesRef,\n        removeFieldEventListener = _ref9.removeFieldEventListener,\n        errorsRef = _ref9.errorsRef,\n        dirtyFieldsRef = _ref9.dirtyFieldsRef,\n        isDirtyRef = _ref9.isDirtyRef,\n        touchedFieldsRef = _ref9.touchedFieldsRef,\n        readFormStateRef = _ref9.readFormStateRef,\n        watchFieldsRef = _ref9.watchFieldsRef,\n        validFieldsRef = _ref9.validFieldsRef,\n        fieldsWithValidationRef = _ref9.fieldsWithValidationRef,\n        fieldArrayDefaultValues = _ref9.fieldArrayDefaultValues,\n        validateSchemaIsValid = _ref9.validateSchemaIsValid,\n        renderWatchedInputs = _ref9.renderWatchedInputs;\n\n  let shouldRender;\n\n  const getDefaultValues = () => [...get(fieldArrayDefaultValues.current[getFieldArrayParentName(name)] ? fieldArrayDefaultValues.current : defaultValuesRef.current, name, [])];\n\n  const memoizedDefaultValues = useRef(getDefaultValues());\n\n  const _useState3 = useState(mapIds(memoizedDefaultValues.current, keyName)),\n        _useState4 = _slicedToArray(_useState3, 2),\n        fields = _useState4[0],\n        setField = _useState4[1];\n\n  const _useState5 = useState(false),\n        _useState6 = _slicedToArray(_useState5, 2),\n        isDeleted = _useState6[0],\n        setIsDeleted = _useState6[1];\n\n  const allFields = useRef(fields);\n  const isNameKey = isKey(name);\n  allFields.current = fields;\n\n  if (isNameKey) {\n    fieldArrayDefaultValues.current[name] = memoizedDefaultValues.current;\n  }\n\n  const appendValueWithKey = values => values.map(value => appendId(value, keyName));\n\n  const setFieldAndValidState = fieldsValues => {\n    setField(fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateSchemaIsValid) {\n      validateSchemaIsValid({\n        [name]: fieldsValues\n      });\n    }\n  };\n\n  const shouldRenderFieldArray = shouldRender => {\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      shouldRender = true;\n    }\n\n    renderWatchedInputs(name);\n    shouldRender && !isWatchAllRef.current && reRender();\n  };\n\n  const resetFields = flagOrFields => {\n    if (readFormStateRef.current.isDirty) {\n      isDirtyRef.current = isUndefined(flagOrFields) || getIsFieldsDifferent(flagOrFields, get(defaultValuesRef.current, name, []));\n    }\n\n    for (const key in fieldsRef.current) {\n      if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\n        removeFieldEventListener(fieldsRef.current[key], true);\n      }\n    }\n  };\n\n  const append = (value, shouldFocus = true) => {\n    shouldRender = false;\n    setFieldAndValidState([...allFields.current, ...(isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)])]);\n\n    if (readFormStateRef.current.dirtyFields) {\n      dirtyFieldsRef.current[name] = [...(dirtyFieldsRef.current[name] || fillEmptyArray(fields.slice(0, 1))), ...filterBooleanArray(value)];\n      isDirtyRef.current = true;\n      shouldRender = true;\n    }\n\n    focusIndexRef.current = shouldFocus ? allFields.current.length : -1;\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const prepend$1 = (value, shouldFocus = true) => {\n    const emptyArray = fillEmptyArray(value);\n    shouldRender = false;\n    resetFields();\n    setFieldAndValidState(prepend(allFields.current, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\n\n    if (isArray(get(errorsRef.current, name))) {\n      errorsRef.current[name] = prepend(get(errorsRef.current, name), emptyArray);\n    }\n\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      touchedFieldsRef.current[name] = prepend(touchedFieldsRef.current[name], emptyArray);\n      shouldRender = true;\n    }\n\n    if ((readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) && dirtyFieldsRef.current[name]) {\n      dirtyFieldsRef.current[name] = prepend(dirtyFieldsRef.current[name], filterBooleanArray(value));\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  const remove = index => {\n    shouldRender = false;\n    resetFields(removeArrayAt(getFieldValueByName(fieldsRef.current, name), index));\n    setFieldAndValidState(removeArrayAt(allFields.current, index));\n    setIsDeleted(true);\n\n    if (isArray(get(errorsRef.current, name))) {\n      errorsRef.current[name] = removeArrayAt(get(errorsRef.current, name), index);\n\n      if (!unique(errorsRef.current[name]).length) {\n        delete errorsRef.current[name];\n      }\n    }\n\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      touchedFieldsRef.current[name] = removeArrayAt(touchedFieldsRef.current[name], index);\n      shouldRender = true;\n    }\n\n    if ((readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) && dirtyFieldsRef.current[name]) {\n      dirtyFieldsRef.current[name] = removeArrayAt(dirtyFieldsRef.current[name], index);\n\n      if (!dirtyFieldsRef.current[name].length) {\n        delete dirtyFieldsRef.current[name];\n      }\n\n      shouldRender = true;\n    }\n\n    if (readFormStateRef.current.isValid && !validateSchemaIsValid) {\n      let fieldIndex = -1;\n      let isFound = false;\n      const isIndexUndefined = isUndefined(index);\n\n      while (fieldIndex++ < fields.length) {\n        const isLast = fieldIndex === fields.length - 1;\n        const isCurrentIndex = (isArray(index) ? index : [index]).indexOf(fieldIndex) >= 0;\n\n        if (isCurrentIndex || isIndexUndefined) {\n          isFound = true;\n        }\n\n        if (!isFound) {\n          continue;\n        }\n\n        for (const key in fields[fieldIndex]) {\n          const currentFieldName = \"\".concat(name, \"[\").concat(fieldIndex, \"].\").concat(key);\n\n          if (isCurrentIndex || isLast || isIndexUndefined) {\n            validFieldsRef.current.delete(currentFieldName);\n            fieldsWithValidationRef.current.delete(currentFieldName);\n          } else {\n            const previousFieldName = \"\".concat(name, \"[\").concat(fieldIndex - 1, \"].\").concat(key);\n\n            if (validFieldsRef.current.has(currentFieldName)) {\n              validFieldsRef.current.add(previousFieldName);\n            }\n\n            if (fieldsWithValidationRef.current.has(currentFieldName)) {\n              fieldsWithValidationRef.current.add(previousFieldName);\n            }\n          }\n        }\n      }\n    }\n\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const insert$1 = (index, value, shouldFocus = true) => {\n    shouldRender = false;\n    const emptyArray = fillEmptyArray(value);\n    resetFields(insert(getFieldValueByName(fieldsRef.current, name), index));\n    setFieldAndValidState(insert(allFields.current, index, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\n\n    if (isArray(get(errorsRef.current, name))) {\n      errorsRef.current[name] = insert(get(errorsRef.current, name), index, emptyArray);\n    }\n\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      touchedFieldsRef.current[name] = insert(touchedFieldsRef.current[name], index, emptyArray);\n      shouldRender = true;\n    }\n\n    if ((readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) && dirtyFieldsRef.current[name]) {\n      dirtyFieldsRef.current[name] = insert(dirtyFieldsRef.current[name], index, filterBooleanArray(value));\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  const swap = (indexA, indexB) => {\n    shouldRender = false;\n    const fieldValues = getFieldValueByName(fieldsRef.current, name);\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields(fieldValues);\n    swapArrayAt(allFields.current, indexA, indexB);\n    setFieldAndValidState([...allFields.current]);\n\n    if (isArray(get(errorsRef.current, name))) {\n      swapArrayAt(get(errorsRef.current, name), indexA, indexB);\n    }\n\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      swapArrayAt(touchedFieldsRef.current[name], indexA, indexB);\n      shouldRender = true;\n    }\n\n    if ((readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) && dirtyFieldsRef.current[name]) {\n      swapArrayAt(dirtyFieldsRef.current[name], indexA, indexB);\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const move = (from, to) => {\n    shouldRender = false;\n    const fieldValues = getFieldValueByName(fieldsRef.current, name);\n    moveArrayAt(fieldValues, from, to);\n    resetFields(fieldValues);\n    moveArrayAt(allFields.current, from, to);\n    setFieldAndValidState([...allFields.current]);\n\n    if (isArray(get(errorsRef.current, name))) {\n      moveArrayAt(get(errorsRef.current, name), from, to);\n    }\n\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      moveArrayAt(touchedFieldsRef.current[name], from, to);\n      shouldRender = true;\n    }\n\n    if ((readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) && dirtyFieldsRef.current[name]) {\n      moveArrayAt(dirtyFieldsRef.current[name], from, to);\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const reset = () => {\n    resetFields();\n    memoizedDefaultValues.current = getDefaultValues();\n    setField(mapIds(memoizedDefaultValues.current, keyName));\n  };\n\n  useEffect(() => {\n    if (isNameKey && isDeleted && fieldArrayDefaultValues.current[name] && fields.length < fieldArrayDefaultValues.current[name].length) {\n      fieldArrayDefaultValues.current[name].pop();\n    }\n\n    if (isWatchAllRef && isWatchAllRef.current) {\n      reRender();\n    } else if (watchFieldsRef) {\n      var _iterator = _createForOfIteratorHelper(watchFieldsRef.current),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          const watchField = _step.value;\n\n          if (watchField.startsWith(name)) {\n            reRender();\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    if (focusIndexRef.current > -1) {\n      for (const key in fieldsRef.current) {\n        const field = fieldsRef.current[key];\n\n        if (key.startsWith(\"\".concat(name, \"[\").concat(focusIndexRef.current, \"]\")) && field.ref.focus) {\n          field.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [fields, name, fieldArrayDefaultValues, isDeleted, isNameKey, reRender, fieldsRef, watchFieldsRef, isWatchAllRef]);\n  useEffect(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    const fieldArrayNames = fieldArrayNamesRef.current;\n    fieldArrayNames.add(name);\n    resetFunctions[name] = reset;\n    return () => {\n      resetFields();\n      delete resetFunctions[name];\n      fieldArrayNames.delete(name);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return {\n    swap: useCallback(swap, [name]),\n    move: useCallback(move, [name]),\n    prepend: useCallback(prepend$1, [name]),\n    append: useCallback(append, [name]),\n    remove: useCallback(remove, [fields, name]),\n    insert: useCallback(insert$1, [name]),\n    fields\n  };\n};\n\nfunction useWatch({\n  control,\n  name,\n  defaultValue\n}) {\n  const methods = useFormContext();\n\n  const _ref10 = control || methods.control,\n        watchFieldsHookRef = _ref10.watchFieldsHookRef,\n        watchFieldsHookRenderRef = _ref10.watchFieldsHookRenderRef,\n        watchInternal = _ref10.watchInternal,\n        defaultValuesRef = _ref10.defaultValuesRef;\n\n  const _useState7 = useState(isUndefined(defaultValue) ? isString(name) ? get(defaultValuesRef.current, name) : isArray(name) ? name.reduce((previous, inputName) => Object.assign(Object.assign({}, previous), {\n    [inputName]: get(defaultValuesRef.current, inputName)\n  }), {}) : defaultValuesRef.current : defaultValue),\n        _useState8 = _slicedToArray(_useState7, 2),\n        value = _useState8[0],\n        setValue = _useState8[1];\n\n  const idRef = useRef();\n  const defaultValueRef = useRef(defaultValue);\n  const nameRef = useRef(name);\n  const updateWatchValue = useCallback(() => setValue(watchInternal(nameRef.current, defaultValueRef.current, idRef.current)), [setValue, watchInternal, defaultValueRef, nameRef, idRef]);\n  useEffect(() => {\n    const id = idRef.current = generateId();\n    const watchFieldsHookRender = watchFieldsHookRenderRef.current;\n    const watchFieldsHook = watchFieldsHookRef.current;\n    watchFieldsHook[id] = new Set();\n    watchFieldsHookRender[id] = updateWatchValue;\n    watchInternal(nameRef.current, defaultValueRef.current, id);\n    return () => {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [nameRef, updateWatchValue, watchFieldsHookRenderRef, watchFieldsHookRef, watchInternal, defaultValueRef]);\n  return isUndefined(value) ? defaultValue : value;\n}\n\nvar getInputValue = (event, isCheckboxInput) => isPrimitive(event) || !isObject(event.target) || isObject(event.target) && !event.type ? event : isCheckboxInput || isUndefined(event.target.value) ? event.target.checked : event.target.value;\n\nconst Controller = _a => {\n  var name = _a.name,\n      rules = _a.rules,\n      as = _a.as,\n      render = _a.render,\n      defaultValue = _a.defaultValue,\n      control = _a.control,\n      onFocus = _a.onFocus,\n      rest = __rest(_a, [\"name\", \"rules\", \"as\", \"render\", \"defaultValue\", \"control\", \"onFocus\"]);\n\n  const methods = useFormContext();\n\n  const _ref11 = control || methods.control,\n        defaultValuesRef = _ref11.defaultValuesRef,\n        setValue = _ref11.setValue,\n        register = _ref11.register,\n        unregister = _ref11.unregister,\n        errorsRef = _ref11.errorsRef,\n        trigger = _ref11.trigger,\n        _ref11$mode = _ref11.mode,\n        isOnSubmit = _ref11$mode.isOnSubmit,\n        isOnBlur = _ref11$mode.isOnBlur,\n        isOnChange = _ref11$mode.isOnChange,\n        _ref11$reValidateMode = _ref11.reValidateMode,\n        isReValidateOnBlur = _ref11$reValidateMode.isReValidateOnBlur,\n        isReValidateOnSubmit = _ref11$reValidateMode.isReValidateOnSubmit,\n        isSubmittedRef = _ref11.isSubmittedRef,\n        touchedFieldsRef = _ref11.touchedFieldsRef,\n        readFormStateRef = _ref11.readFormStateRef,\n        reRender = _ref11.reRender,\n        fieldsRef = _ref11.fieldsRef,\n        fieldArrayNamesRef = _ref11.fieldArrayNamesRef,\n        unmountFieldsStateRef = _ref11.unmountFieldsStateRef,\n        formState = _ref11.formState;\n\n  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n  const getInitialValue = () => !isUndefined(unmountFieldsStateRef.current[name]) && isNotFieldArray ? unmountFieldsStateRef.current[name] : isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue;\n\n  const _useState9 = useState(getInitialValue()),\n        _useState10 = _slicedToArray(_useState9, 2),\n        value = _useState10[0],\n        setInputStateValue = _useState10[1];\n\n  const valueRef = useRef(value);\n  const isCheckboxInput = isBoolean(value);\n  const onFocusRef = useRef(onFocus);\n  const isSubmitted = isSubmittedRef.current;\n\n  const shouldValidate = () => !skipValidation({\n    hasError: !!get(errorsRef.current, name),\n    isOnBlur,\n    isOnSubmit,\n    isOnChange,\n    isReValidateOnBlur,\n    isReValidateOnSubmit,\n    isSubmitted\n  });\n\n  const commonTask = event => {\n    const data = getInputValue(event[0], isCheckboxInput);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  };\n\n  const registerField = useCallback(() => {\n    if (fieldsRef.current[name]) {\n      fieldsRef.current[name] = Object.assign({\n        ref: fieldsRef.current[name].ref\n      }, rules);\n    } else {\n      register(Object.defineProperty({\n        name,\n        focus: onFocusRef.current\n      }, VALUE, {\n        set(data) {\n          setInputStateValue(data);\n          valueRef.current = data;\n        },\n\n        get() {\n          return valueRef.current;\n        }\n\n      }), rules);\n    }\n  }, [fieldsRef, rules, name, onFocusRef, register]);\n  useEffect(() => () => {\n    !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\n  }, [unregister, name, fieldArrayNamesRef]);\n  useEffect(() => {\n    registerField();\n  }, [registerField]); // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  useEffect(() => {\n    if (!fieldsRef.current[name]) {\n      registerField();\n\n      if (isNotFieldArray) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  });\n\n  const onBlur = () => {\n    if (readFormStateRef.current.touched && !get(touchedFieldsRef.current, name)) {\n      set(touchedFieldsRef.current, name, true);\n      reRender();\n    }\n\n    if (isOnBlur || formState.isSubmitted && isReValidateOnBlur) {\n      trigger(name);\n    }\n  };\n\n  const onChange = (...event) => setValue(name, commonTask(event), {\n    shouldValidate: shouldValidate(),\n    shouldDirty: true\n  });\n\n  const props = Object.assign(Object.assign(Object.assign({}, rest), {\n    onChange,\n    onBlur\n  }), {\n    [isCheckboxInput ? 'checked' : VALUE]: value\n  });\n  return as ? isValidElement(as) ? cloneElement(as, props) : createElement(as, props) : render ? render({\n    onChange,\n    onBlur,\n    value\n  }) : null;\n};\n\nexport { Controller, FormContext, FormProvider, appendErrors, get, transformToNestObject, useFieldArray, useForm, useFormContext, useWatch };","map":{"version":3,"sources":["../src/utils/isHTMLElement.ts","../src/constants.ts","../src/logic/attachEventListeners.ts","../src/utils/isNullOrUndefined.ts","../src/utils/isArray.ts","../src/utils/isObject.ts","../src/utils/isKey.ts","../src/utils/stringToPath.ts","../src/utils/set.ts","../src/logic/transformToNestObject.ts","../src/utils/isUndefined.ts","../src/utils/unique.ts","../src/utils/get.ts","../src/logic/focusOnErrorField.ts","../src/logic/removeAllEventListeners.ts","../src/logic/getRadioValue.ts","../src/logic/getMultipleSelectValue.ts","../src/utils/isRadioInput.ts","../src/utils/isFileInput.ts","../src/utils/isCheckBoxInput.ts","../src/utils/isMultipleSelect.ts","../src/utils/isEmptyString.ts","../src/logic/getCheckboxValue.ts","../src/logic/getFieldValue.ts","../src/utils/isDetached.ts","../src/utils/isEmptyObject.ts","../src/utils/unset.ts","../src/logic/findRemovedFieldAndRemoveListener.ts","../src/utils/isString.ts","../src/logic/getFieldsValues.ts","../src/utils/compareObject.ts","../src/utils/isSameError.ts","../src/logic/shouldRenderBasedOnError.ts","../src/utils/isRegex.ts","../src/logic/getValueAndMessage.ts","../src/utils/isFunction.ts","../src/utils/isBoolean.ts","../src/utils/isMessage.ts","../src/logic/getValidateError.ts","../src/logic/appendErrors.ts","../src/logic/validateField.ts","../src/utils/isPrimitive.ts","../src/utils/getPath.ts","../src/logic/assignWatchFields.ts","../src/logic/skipValidation.ts","../src/logic/getFieldArrayParentName.ts","../src/logic/getFieldArrayValueByName.ts","../src/logic/getIsFieldsDifferent.ts","../src/logic/isNameInFieldArray.ts","../src/utils/isSelectInput.ts","../src/utils/onDomRemove.ts","../src/utils/validationModeChecker.ts","../src/utils/isRadioOrCheckbox.ts","../src/useForm.ts","../src/useFormContext.tsx","../src/logic/generateId.ts","../src/logic/mapIds.ts","../src/utils/remove.ts","../src/utils/move.ts","../src/utils/swap.ts","../src/utils/prepend.ts","../src/utils/insert.ts","../src/utils/fillEmptyArray.ts","../src/utils/filterBooleanArray.ts","../src/useFieldArray.ts","../src/useWatch.ts","../src/logic/getInputValue.ts","../src/controller.tsx"],"names":["isCheckBox","getFieldsValue","getPath","React.useRef","React.useState","React.useCallback","getFieldArrayValueByName","React.useEffect","React.createContext","React.useContext","React.createElement","prepend","prependAt","insert","insertAt","React.isValidElement","React.cloneElement"],"mappings":"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","sourcesContent":["export default (value: any): value is HTMLElement =>\n  value instanceof HTMLElement;\n","import { ValidationMode } from './types/form';\n\nexport const EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input',\n};\n\nexport const VALIDATION_MODE: ValidationMode = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  all: 'all',\n};\n\nexport const VALUE = 'value';\n\nexport const SELECT = 'select';\n\nexport const UNDEFINED = 'undefined';\n\nexport const INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate',\n};\n","import isHTMLElement from '../utils/isHTMLElement';\nimport { EVENTS } from '../constants';\nimport { Field } from '../types/form';\n\nexport default function attachEventListeners({\n  field: { ref },\n  handleChange,\n  isRadioOrCheckbox,\n}: {\n  field: Field;\n  isRadioOrCheckbox: boolean;\n  handleChange?: EventListenerOrEventListenerObject;\n}): void {\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(\n      isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT,\n      handleChange,\n    );\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n","export default (value: unknown): value is null | undefined => value == null;\n","export default <T>(value: unknown): value is T[] => Array.isArray(value);\n","import isNullOrUndefined from './isNullOrUndefined';\nimport isArray from './isArray';\n\nexport const isObjectType = (value: unknown) => typeof value === 'object';\n\nexport default <T extends object>(value: unknown): value is T =>\n  !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);\n","import isArray from './isArray';\n\nexport default (value: [] | string) =>\n  !isArray(value) &&\n  (/^\\w*$/.test(value) ||\n    !/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/.test(value));\n","export default (input: string): (string | number)[] => {\n  const result: (string | number)[] = [];\n\n  input.replace(\n    /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,\n    (\n      match: string,\n      mathNumber: string,\n      mathQuote: string,\n      originalString: string,\n    ): any => {\n      result.push(\n        mathQuote\n          ? originalString.replace(/\\\\(\\\\)?/g, '$1')\n          : mathNumber || match,\n      );\n    },\n  );\n\n  return result;\n};\n","import isObject from './isObject';\nimport isArray from './isArray';\nimport isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport { FieldValues } from '../types/form';\n\nexport default function set(object: FieldValues, path: string, value: any) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue: string | object = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue =\n        isObject(objValue) || isArray(objValue)\n          ? objValue\n          : !isNaN(+tempPath[index + 1])\n          ? []\n          : {};\n    }\n    object[key] = newValue;\n    object = object[key];\n  }\n  return object;\n}\n","import set from '../utils/set';\nimport isKey from '../utils/isKey';\nimport { FieldValues } from '../types/form';\n\nexport default (data: FieldValues): any =>\n  Object.entries(data).reduce(\n    (previous: FieldValues, [key, value]): FieldValues => {\n      if (!isKey(key)) {\n        set(previous, key, value);\n        return previous;\n      }\n\n      return { ...previous, [key]: value };\n    },\n    {},\n  );\n","export default (val: unknown): val is undefined => val === undefined;\n","export default (value: any[]) => value.filter(Boolean);\n","import isUndefined from './isUndefined';\nimport isNullOrUndefined from './isNullOrUndefined';\nimport unique from './unique';\n\nexport default (obj: any, path: string, defaultValue?: any) => {\n  const result = unique(path.split(/[,[\\].]+?/)).reduce(\n    (result, key) => (isNullOrUndefined(result) ? result : result[key]),\n    obj,\n  );\n\n  return isUndefined(result) || result === obj\n    ? isUndefined(obj[path])\n      ? defaultValue\n      : obj[path]\n    : result;\n};\n","import get from '../utils/get';\nimport { FieldErrors, FieldRefs } from '../types/form';\n\nexport default <TFieldValues>(\n  fields: FieldRefs<TFieldValues>,\n  fieldErrors: FieldErrors<TFieldValues>,\n) => {\n  for (const key in fields) {\n    if (get(fieldErrors, key)) {\n      const field = fields[key];\n\n      if (field) {\n        if (field.ref.focus) {\n          field.ref.focus();\n\n          break;\n        } else if (field.options) {\n          field.options[0].ref.focus();\n\n          break;\n        }\n      }\n    }\n  }\n};\n","import isHTMLElement from '../utils/isHTMLElement';\nimport { EVENTS } from '../constants';\nimport { Ref } from '../types/form';\n\nexport default (\n  ref: Ref,\n  validateWithStateUpdate: EventListenerOrEventListenerObject,\n): void => {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n","import isArray from '../utils/isArray';\nimport { RadioOrCheckboxOption } from '../types/form';\n\ntype RadioFieldResult = {\n  isValid: boolean;\n  value: number | string;\n};\n\nconst defaultReturn: RadioFieldResult = {\n  isValid: false,\n  value: '',\n};\n\nexport default (options?: RadioOrCheckboxOption[]): RadioFieldResult =>\n  isArray(options)\n    ? options.reduce(\n        (previous, option): RadioFieldResult =>\n          option && option.ref.checked\n            ? {\n                isValid: true,\n                value: option.ref.value,\n              }\n            : previous,\n        defaultReturn,\n      )\n    : defaultReturn;\n","export default (\n  options: HTMLOptionElement[] | HTMLOptionsCollection,\n): string[] =>\n  [...options]\n    .filter(({ selected }): boolean => selected)\n    .map(({ value }): string => value);\n","import { FieldElement } from '../types/form';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'radio';\n","import { FieldElement } from '../types/form';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'file';\n","import { FieldElement } from '../types/form';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'checkbox';\n","import { FieldElement } from '../types/form';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-multiple`;\n","export default (value: string) => value === '';\n","import isArray from '../utils/isArray';\nimport isUndefined from '../utils/isUndefined';\nimport isEmptyString from '../utils/isEmptyString';\nimport { RadioOrCheckboxOption } from '../types/form';\n\ntype CheckboxFieldResult = {\n  isValid: boolean;\n  value: string | string[] | boolean;\n};\n\nconst defaultResult: CheckboxFieldResult = {\n  value: false,\n  isValid: false,\n};\n\nconst validResult = { value: true, isValid: true };\n\nexport default (options?: RadioOrCheckboxOption[]): CheckboxFieldResult => {\n  if (isArray(options)) {\n    if (options.length > 1) {\n      const values = options\n        .filter((option) => option && option.ref.checked)\n        .map(({ ref: { value } }) => value);\n      return { value: values, isValid: !!values.length };\n    }\n\n    const { checked, value, attributes } = options[0].ref;\n\n    return checked\n      ? attributes && !isUndefined((attributes as any).value)\n        ? isUndefined(value) || isEmptyString(value)\n          ? validResult\n          : { value: value, isValid: true }\n        : validResult\n      : defaultResult;\n  }\n\n  return defaultResult;\n};\n","import getRadioValue from './getRadioValue';\nimport getMultipleSelectValue from './getMultipleSelectValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport isFileInput from '../utils/isFileInput';\nimport isCheckBox from '../utils/isCheckBoxInput';\nimport isMultipleSelect from '../utils/isMultipleSelect';\nimport getCheckboxValue from './getCheckboxValue';\nimport { FieldRefs, FieldValues, InternalFieldName } from '../types/form';\n\nexport default function getFieldValue<TFieldValues extends FieldValues>(\n  fields: FieldRefs<TFieldValues>,\n  name: InternalFieldName<TFieldValues>,\n) {\n  if (fields[name]) {\n    const field = fields[name]!;\n    const {\n      ref: { value },\n      ref,\n    } = field;\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return field ? getRadioValue(field.options).value : '';\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBox(ref)) {\n      return field ? getCheckboxValue(field.options).value : false;\n    }\n\n    return value;\n  }\n}\n","import { Ref } from '../types/form';\n\nexport default function isDetached(element: Ref): boolean {\n  if (!element) {\n    return true;\n  }\n\n  if (\n    !(element instanceof HTMLElement) ||\n    element.nodeType === Node.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n\n  return isDetached(element.parentNode as Ref);\n}\n","import isObject from './isObject';\nimport { EmptyObject } from '../types/utils';\n\nexport default (value: unknown): value is EmptyObject =>\n  isObject(value) && !Object.keys(value).length;\n","import isArray from './isArray';\nimport isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport isEmptyObject from './isEmptyObject';\nimport isObject from './isObject';\nimport isUndefined from './isUndefined';\n\nfunction baseGet(object: any, updatePath: (string | number)[]) {\n  const path = updatePath.slice(0, -1);\n  const length = path.length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n  return index == length ? object : undefined;\n}\n\nexport default function unset(object: any, path: string) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject =\n    updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef = undefined;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef = undefined;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (\n        currentPathsLength === index &&\n        ((isObject(objectRef) && isEmptyObject(objectRef)) ||\n          (isArray(objectRef) &&\n            !objectRef.filter((data) => isObject(data) && !isEmptyObject(data))\n              .length))\n      ) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n","import * as React from 'react';\nimport removeAllEventListeners from './removeAllEventListeners';\nimport getFieldValue from './getFieldValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isDetached from '../utils/isDetached';\nimport isArray from '../utils/isArray';\nimport unset from '../utils/unset';\nimport unique from '../utils/unique';\nimport isUndefined from '../utils/isUndefined';\nimport { Field, FieldRefs, FieldValues, Ref } from '../types/form';\n\nconst isSameRef = (fieldValue: Field, ref: Ref) =>\n  fieldValue && fieldValue.ref === ref;\n\nexport default function findRemovedFieldAndRemoveListener<\n  TFieldValues extends FieldValues\n>(\n  fields: FieldRefs<TFieldValues>,\n  handleChange: ({ type, target }: Event) => Promise<void | boolean>,\n  field: Field,\n  unmountFieldsStateRef: React.MutableRefObject<Record<string, any>>,\n  shouldUnregister?: boolean,\n  forceDelete?: boolean,\n): void {\n  const {\n    ref,\n    ref: { name, type },\n    mutationWatcher,\n  } = field;\n  const fieldRef = fields[name] as Field;\n\n  if (!shouldUnregister) {\n    const value = getFieldValue(fields, name);\n\n    if (!isUndefined(value)) {\n      unmountFieldsStateRef.current[name] = value;\n    }\n  }\n\n  if (!type) {\n    delete fields[name];\n    return;\n  }\n\n  if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldRef) {\n    const { options } = fieldRef;\n\n    if (isArray(options) && options.length) {\n      unique(options).forEach((option, index): void => {\n        const { ref, mutationWatcher } = option;\n        if ((ref && isDetached(ref) && isSameRef(option, ref)) || forceDelete) {\n          removeAllEventListeners(ref, handleChange);\n\n          if (mutationWatcher) {\n            mutationWatcher.disconnect();\n          }\n\n          unset(options, `[${index}]`);\n        }\n      });\n\n      if (options && !unique(options).length) {\n        delete fields[name];\n      }\n    } else {\n      delete fields[name];\n    }\n  } else if ((isDetached(ref) && isSameRef(fieldRef, ref)) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n\n    if (mutationWatcher) {\n      mutationWatcher.disconnect();\n    }\n\n    delete fields[name];\n  }\n}\n","export default (value: unknown): value is string => typeof value === 'string';\n","import getFieldValue from './getFieldValue';\nimport isString from '../utils/isString';\nimport isArray from '../utils/isArray';\nimport isUndefined from '../utils/isUndefined';\nimport { InternalFieldName, FieldValues, FieldRefs } from '../types/form';\n\nexport default <TFieldValues extends FieldValues>(\n  fields: FieldRefs<TFieldValues>,\n  search?:\n    | InternalFieldName<TFieldValues>\n    | InternalFieldName<TFieldValues>[]\n    | { nest: boolean },\n) => {\n  const output = {} as TFieldValues;\n\n  for (const name in fields) {\n    if (\n      isUndefined(search) ||\n      (isString(search)\n        ? name.startsWith(search)\n        : isArray(search) && search.find((data) => name.startsWith(data)))\n    ) {\n      output[name as InternalFieldName<TFieldValues>] = getFieldValue(\n        fields,\n        name,\n      );\n    }\n  }\n\n  return output;\n};\n","export default (objectA: any = {}, objectB: any = {}) => {\n  const objectAKeys = Object.keys(objectA);\n\n  return (\n    objectAKeys.length === Object.keys(objectB).length &&\n    objectAKeys.every((key) => objectB[key] && objectB[key] === objectA[key])\n  );\n};\n","import isObject from './isObject';\nimport compareObject from './compareObject';\nimport { FieldError } from '../types/form';\n\nexport default (\n  error: FieldError | undefined,\n  { type, types, message }: FieldError,\n): boolean =>\n  isObject(error) &&\n  error.type === type &&\n  error.message === message &&\n  compareObject(error.types, types);\n","import isEmptyObject from '../utils/isEmptyObject';\nimport isSameError from '../utils/isSameError';\nimport get from '../utils/get';\nimport {\n  FieldValues,\n  InternalFieldName,\n  FieldErrors,\n  FlatFieldErrors,\n} from '../types/form';\n\nexport default function shouldRenderBasedOnError<\n  TFieldValues extends FieldValues\n>({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation,\n}: {\n  errors: FieldErrors<TFieldValues>;\n  error: FlatFieldErrors<TFieldValues>;\n  name: InternalFieldName<TFieldValues>;\n  validFields: Set<InternalFieldName<TFieldValues>>;\n  fieldsWithValidation: Set<InternalFieldName<TFieldValues>>;\n}): boolean {\n  const isFieldValid = isEmptyObject(error);\n  const isFormValid = isEmptyObject(errors);\n  const currentFieldError = get(error, name);\n  const existFieldError = get(errors, name);\n\n  if (isFieldValid && validFields.has(name)) {\n    return false;\n  }\n\n  if (\n    isFormValid !== isFieldValid ||\n    (!isFormValid && !existFieldError) ||\n    (isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name))\n  ) {\n    return true;\n  }\n\n  return currentFieldError && !isSameError(existFieldError, currentFieldError);\n}\n","export default (value: unknown): value is RegExp => value instanceof RegExp;\n","import isObject from '../utils/isObject';\nimport isRegex from '../utils/isRegex';\nimport { ValidationRule, ValidationValueMessage } from '../types/form';\n\nconst isValueMessage = (\n  value?: ValidationRule,\n): value is ValidationValueMessage => isObject(value) && !isRegex(value);\n\nexport default (validationData?: ValidationRule) =>\n  isValueMessage(validationData)\n    ? validationData\n    : {\n        value: validationData,\n        message: '',\n      };\n","export default (value: unknown): value is Function =>\n  typeof value === 'function';\n","export default (value: unknown): value is boolean => typeof value === 'boolean';\n","import { isValidElement } from 'react';\nimport isString from '../utils/isString';\nimport isObject from '../utils/isObject';\nimport { Message } from '../types/form';\n\nexport default (value: unknown): value is Message =>\n  isString(value) || (isObject(value) && isValidElement(value));\n","import isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport { FieldError, ValidateResult, Ref } from '../types/form';\n\nexport default function getValidateError(\n  result: ValidateResult,\n  ref: Ref,\n  type = 'validate',\n): FieldError | void {\n  if (isMessage(result) || (isBoolean(result) && !result)) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref,\n    };\n  }\n}\n","import {\n  InternalFieldName,\n  ValidateResult,\n  FlatFieldErrors,\n} from '../types/form';\n\nexport default <TFieldValues>(\n  name: InternalFieldName<TFieldValues>,\n  validateAllFieldCriteria: boolean,\n  errors: FlatFieldErrors<TFieldValues>,\n  type: string,\n  message: ValidateResult,\n) => {\n  if (validateAllFieldCriteria) {\n    const error = errors[name];\n\n    return {\n      ...error,\n      types: {\n        ...(error && error.types ? error.types : {}),\n        [type]: message || true,\n      },\n    };\n  }\n\n  return {};\n};\n","import * as React from 'react';\nimport getRadioValue from './getRadioValue';\nimport getCheckboxValue from './getCheckboxValue';\nimport isNullOrUndefined from '../utils/isNullOrUndefined';\nimport isRadioInput from '../utils/isRadioInput';\nimport getValueAndMessage from './getValueAndMessage';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isString from '../utils/isString';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isObject from '../utils/isObject';\nimport isFunction from '../utils/isFunction';\nimport getFieldsValue from './getFieldValue';\nimport isRegex from '../utils/isRegex';\nimport isEmptyString from '../utils/isEmptyString';\nimport isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport getValidateError from './getValidateError';\nimport appendErrors from './appendErrors';\nimport { INPUT_VALIDATION_RULES } from '../constants';\nimport {\n  Field,\n  FieldValues,\n  FieldRefs,\n  Message,\n  FieldError,\n  InternalFieldName,\n  FlatFieldErrors,\n} from '../types/form';\n\nexport default async <TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  validateAllFieldCriteria: boolean,\n  {\n    ref,\n    ref: { type, value },\n    options,\n    required,\n    maxLength,\n    minLength,\n    min,\n    max,\n    pattern,\n    validate,\n  }: Field,\n): Promise<FlatFieldErrors<TFieldValues>> => {\n  const fields = fieldsRef.current;\n  const name: InternalFieldName<TFieldValues> = ref.name;\n  const error: FlatFieldErrors<TFieldValues> = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = isEmptyString(value);\n  const appendErrorsCurry = appendErrors.bind(\n    null,\n    name,\n    validateAllFieldCriteria,\n    error,\n  );\n  const getMinMaxMessage = (\n    exceedMax: boolean,\n    maxLengthMessage: Message,\n    minLengthMessage: Message,\n    maxType = INPUT_VALIDATION_RULES.maxLength,\n    minType = INPUT_VALIDATION_RULES.minLength,\n  ) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = {\n      type: exceedMax ? maxType : minType,\n      message,\n      ref,\n      ...(exceedMax\n        ? appendErrorsCurry(maxType, message)\n        : appendErrorsCurry(minType, message)),\n    };\n  };\n\n  if (\n    required &&\n    ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\n      (isBoolean(value) && !value) ||\n      (isCheckBox && !getCheckboxValue(options).isValid) ||\n      (isRadio && !getRadioValue(options).isValid))\n  ) {\n    const { value: requiredValue, message: requiredMessage } = isMessage(\n      required,\n    )\n      ? { value: !!required, message: required }\n      : getValueAndMessage(required);\n\n    if (requiredValue) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.required,\n        message: requiredMessage,\n        ref: isRadioOrCheckbox ? (fields[name] as Field).options?.[0].ref : ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\n    let exceedMax;\n    let exceedMin;\n    const { value: maxValue, message: maxMessage } = getValueAndMessage(max);\n    const { value: minValue, message: minMessage } = getValueAndMessage(min);\n\n    if (type === 'number' || (!type && !isNaN(value))) {\n      const valueNumber =\n        (ref as HTMLInputElement).valueAsNumber || parseFloat(value);\n      if (!isNullOrUndefined(maxValue)) {\n        exceedMax = valueNumber > maxValue;\n      }\n      if (!isNullOrUndefined(minValue)) {\n        exceedMin = valueNumber < minValue;\n      }\n    } else {\n      const valueDate =\n        (ref as HTMLInputElement).valueAsDate || new Date(value);\n      if (isString(maxValue)) {\n        exceedMax = valueDate > new Date(maxValue);\n      }\n      if (isString(minValue)) {\n        exceedMin = valueDate < new Date(minValue);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        !!exceedMax,\n        maxMessage,\n        minMessage,\n        INPUT_VALIDATION_RULES.max,\n        INPUT_VALIDATION_RULES.min,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && !isEmpty && (maxLength || minLength)) {\n    const {\n      value: maxLengthValue,\n      message: maxLengthMessage,\n    } = getValueAndMessage(maxLength);\n    const {\n      value: minLengthValue,\n      message: minLengthMessage,\n    } = getValueAndMessage(minLength);\n    const inputLength = value.toString().length;\n    const exceedMax =\n      !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\n    const exceedMin =\n      !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (pattern && !isEmpty) {\n    const { value: patternValue, message: patternMessage } = getValueAndMessage(\n      pattern,\n    );\n\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.pattern,\n        message: patternMessage,\n        ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const fieldValue = getFieldsValue(fields, name);\n    const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = {\n          ...validateError,\n          ...appendErrorsCurry(\n            INPUT_VALIDATION_RULES.validate,\n            validateError.message,\n          ),\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {} as FieldError;\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(fieldValue);\n        const validateError = getValidateError(\n          validateResult,\n          validateRef,\n          key,\n        );\n\n        if (validateError) {\n          validationResult = {\n            ...validateError,\n            ...appendErrorsCurry(key, validateError.message),\n          };\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = {\n          ref: validateRef,\n          ...validationResult,\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n","import isNullOrUndefined from './isNullOrUndefined';\nimport { isObjectType } from './isObject';\nimport { Primitive } from '../types/utils';\n\nexport default (value: unknown): value is Primitive =>\n  isNullOrUndefined(value) || !isObjectType(value);\n","import isPrimitive from './isPrimitive';\nimport { FieldValues, InternalFieldName } from '../types/form';\nimport isArray from './isArray';\n\nconst getPath = <TFieldValues extends FieldValues = FieldValues>(\n  path: InternalFieldName<TFieldValues>,\n  values: TFieldValues | any[],\n): any[] => {\n  const getInnerPath = (\n    value: any,\n    key: number | string,\n    isObject?: boolean,\n  ) => {\n    const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\n    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\n  };\n\n  return isArray(values)\n    ? values.map((value, key) => getInnerPath(value, key))\n    : Object.entries(values).map(([key, value]) =>\n        getInnerPath(value, key, true),\n      );\n};\n\nexport default <TFieldValues extends FieldValues = FieldValues>(\n  parentPath: InternalFieldName<TFieldValues>,\n  value: TFieldValues,\n) => getPath(parentPath, value).flat(Infinity);\n","import transformToNestObject from './transformToNestObject';\nimport get from '../utils/get';\nimport getPath from '../utils/getPath';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isUndefined from '../utils/isUndefined';\nimport { DeepPartial } from '../types/utils';\nimport {\n  FieldValue,\n  FieldValues,\n  InternalFieldName,\n  UnpackNestedValue,\n} from '../types/form';\n\nexport default <TFieldValues extends FieldValues>(\n  fieldValues: TFieldValues,\n  fieldName: InternalFieldName<TFieldValues>,\n  watchFields: Set<InternalFieldName<TFieldValues>>,\n  inputValue: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  isSingleField?: boolean,\n):\n  | FieldValue<TFieldValues>\n  | UnpackNestedValue<DeepPartial<TFieldValues>>\n  | undefined => {\n  let value;\n\n  watchFields.add(fieldName);\n\n  if (isEmptyObject(fieldValues)) {\n    value = undefined;\n  } else if (!isUndefined(fieldValues[fieldName])) {\n    value = fieldValues[fieldName];\n  } else {\n    value = get(transformToNestObject(fieldValues), fieldName);\n\n    if (!isUndefined(value)) {\n      getPath<TFieldValues>(fieldName, value).forEach((name: string) =>\n        watchFields.add(name),\n      );\n    }\n  }\n\n  return isUndefined(value)\n    ? isSingleField\n      ? inputValue\n      : get(inputValue, fieldName)\n    : value;\n};\n","export default ({\n  isOnChange,\n  hasError,\n  isBlurEvent,\n  isOnSubmit,\n  isReValidateOnSubmit,\n  isOnBlur,\n  isReValidateOnBlur,\n  isSubmitted,\n}: {\n  hasError: boolean;\n  isOnChange: boolean;\n  isBlurEvent?: boolean;\n  isOnSubmit: boolean;\n  isOnBlur: boolean;\n  isReValidateOnSubmit: boolean;\n  isReValidateOnBlur: boolean;\n  isSubmitted: boolean;\n}) =>\n  (isOnChange && isBlurEvent) ||\n  (isOnSubmit && isReValidateOnSubmit) ||\n  (isOnSubmit && !isSubmitted) ||\n  (isOnBlur && !isBlurEvent && !hasError) ||\n  (isReValidateOnBlur && !isBlurEvent && hasError) ||\n  (isReValidateOnSubmit && isSubmitted);\n","export default (name: string) => name.substring(0, name.indexOf('['));\n","import transformToNestObject from './transformToNestObject';\nimport getFieldsValues from './getFieldsValues';\nimport get from '../utils/get';\nimport { FieldValues, FieldRefs, InternalFieldName } from '../types/form';\n\nexport default <TFieldValues extends FieldValues = FieldValues>(\n  fields: FieldRefs<TFieldValues>,\n  name?: InternalFieldName<FieldValues>,\n) => {\n  const results = transformToNestObject(getFieldsValues(fields));\n  return name ? get(results, name, results) : results;\n};\n","import isUndefined from '../utils/isUndefined';\nimport isArray from '../utils/isArray';\n\nexport default function getIsFieldsDifferent(\n  referenceArray: unknown[],\n  differenceArray: unknown[],\n) {\n  if (\n    !isArray<any>(referenceArray) ||\n    !isArray<any>(differenceArray) ||\n    referenceArray.length !== differenceArray.length\n  ) {\n    return true;\n  }\n\n  for (let i = 0; i < referenceArray.length; i++) {\n    const dataA = referenceArray[i];\n    const dataB = differenceArray[i];\n\n    if (\n      isUndefined(dataB) ||\n      Object.keys(dataA).length !== Object.keys(dataB).length\n    ) {\n      return true;\n    }\n\n    for (const key in dataA) {\n      if (dataA[key] !== dataB[key]) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n","export const isMatchFieldArrayName = (name: string, searchName: string) =>\n  RegExp(\n    `^${searchName}[\\\\d+]`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]'),\n  ).test(name);\n\nexport default (names: Set<string>, name: string) =>\n  [...names].some((current) => isMatchFieldArrayName(name, current));\n","import { FieldElement } from '../types/form';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-one`;\n","import { Ref, MutationWatcher } from '../types/form';\nimport isDetached from './isDetached';\n\nexport default function onDomRemove(\n  element: Ref,\n  onDetachCallback: VoidFunction,\n): MutationWatcher {\n  const observer = new MutationObserver((): void => {\n    if (isDetached(element)) {\n      observer.disconnect();\n      onDetachCallback();\n    }\n  });\n\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true,\n  });\n\n  return observer;\n}\n","import { VALIDATION_MODE } from '../constants';\nimport { Mode } from '../types/form';\n\nexport default (\n  mode?: Mode,\n): {\n  isOnSubmit: boolean;\n  isOnBlur: boolean;\n  isOnChange: boolean;\n  isOnAll: boolean;\n} => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n});\n","import isRadioInput from './isRadioInput';\nimport isCheckBoxInput from './isCheckBoxInput';\nimport { FieldElement } from '../types/form';\n\nexport default (ref: FieldElement): ref is HTMLInputElement =>\n  isRadioInput(ref) || isCheckBoxInput(ref);\n","import * as React from 'react';\nimport attachEventListeners from './logic/attachEventListeners';\nimport transformToNestObject from './logic/transformToNestObject';\nimport focusOnErrorField from './logic/focusOnErrorField';\nimport findRemovedFieldAndRemoveListener from './logic/findRemovedFieldAndRemoveListener';\nimport getFieldsValues from './logic/getFieldsValues';\nimport getFieldValue from './logic/getFieldValue';\nimport shouldRenderBasedOnError from './logic/shouldRenderBasedOnError';\nimport validateField from './logic/validateField';\nimport assignWatchFields from './logic/assignWatchFields';\nimport skipValidation from './logic/skipValidation';\nimport getFieldArrayParentName from './logic/getFieldArrayParentName';\nimport getFieldArrayValueByName from './logic/getFieldArrayValueByName';\nimport getIsFieldsDifferent from './logic/getIsFieldsDifferent';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport isCheckBoxInput from './utils/isCheckBoxInput';\nimport isEmptyObject from './utils/isEmptyObject';\nimport isRadioInput from './utils/isRadioInput';\nimport isSelectInput from './utils/isSelectInput';\nimport isFileInput from './utils/isFileInput';\nimport isObject from './utils/isObject';\nimport isPrimitive from './utils/isPrimitive';\nimport isFunction from './utils/isFunction';\nimport isArray from './utils/isArray';\nimport isString from './utils/isString';\nimport isSameError from './utils/isSameError';\nimport isUndefined from './utils/isUndefined';\nimport onDomRemove from './utils/onDomRemove';\nimport get from './utils/get';\nimport set from './utils/set';\nimport unset from './utils/unset';\nimport modeChecker from './utils/validationModeChecker';\nimport isMultipleSelect from './utils/isMultipleSelect';\nimport unique from './utils/unique';\nimport isNullOrUndefined from './utils/isNullOrUndefined';\nimport isRadioOrCheckboxFunction from './utils/isRadioOrCheckbox';\nimport isHTMLElement from './utils/isHTMLElement';\nimport { EVENTS, UNDEFINED, VALIDATION_MODE } from './constants';\nimport {\n  UseFormMethods,\n  FieldValues,\n  UnpackNestedValue,\n  FieldName,\n  InternalFieldName,\n  FieldValue,\n  FieldErrors,\n  Field,\n  FieldRefs,\n  UseFormOptions,\n  ValidationRules,\n  SubmitHandler,\n  FieldElement,\n  FormStateProxy,\n  ReadFormState,\n  Ref,\n  HandleChange,\n  Touched,\n  FieldError,\n  RadioOrCheckboxOption,\n  OmitResetState,\n  DefaultValuesAtRender,\n  FlatFieldErrors,\n  NestedValue,\n  SetValueConfig,\n  ErrorOption,\n} from './types/form';\nimport { LiteralToPrimitive, DeepPartial, NonUndefined } from './types/utils';\n\nexport function useForm<\n  TFieldValues extends FieldValues = FieldValues,\n  TContext extends object = object\n>({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {} as UnpackNestedValue<DeepPartial<TFieldValues>>,\n  shouldFocusError = true,\n  shouldUnregister = true,\n  criteriaMode,\n}: UseFormOptions<TFieldValues, TContext> = {}): UseFormMethods<TFieldValues> {\n  const fieldsRef = React.useRef<FieldRefs<TFieldValues>>({});\n  const errorsRef = React.useRef<FieldErrors<TFieldValues>>({});\n  const touchedFieldsRef = React.useRef<Touched<TFieldValues>>({});\n  const fieldArrayDefaultValues = React.useRef<Record<string, unknown[]>>({});\n  const watchFieldsRef = React.useRef(\n    new Set<InternalFieldName<TFieldValues>>(),\n  );\n  const dirtyFieldsRef = React.useRef<Touched<TFieldValues>>({});\n  const watchFieldsHookRef = React.useRef<\n    Record<string, Set<InternalFieldName<TFieldValues>>>\n  >({});\n  const watchFieldsHookRenderRef = React.useRef<Record<string, Function>>({});\n  const fieldsWithValidationRef = React.useRef(\n    new Set<InternalFieldName<TFieldValues>>(),\n  );\n  const validFieldsRef = React.useRef(\n    new Set<InternalFieldName<TFieldValues>>(),\n  );\n  const isValidRef = React.useRef(true);\n  const defaultValuesRef = React.useRef<\n    | FieldValue<UnpackNestedValue<TFieldValues>>\n    | UnpackNestedValue<DeepPartial<TFieldValues>>\n  >(defaultValues);\n  const defaultValuesAtRenderRef = React.useRef(\n    {} as DefaultValuesAtRender<TFieldValues>,\n  );\n  const isUnMount = React.useRef(false);\n  const isWatchAllRef = React.useRef(false);\n  const isSubmittedRef = React.useRef(false);\n  const isDirtyRef = React.useRef(false);\n  const submitCountRef = React.useRef(0);\n  const isSubmittingRef = React.useRef(false);\n  const handleChangeRef = React.useRef<HandleChange>();\n  const unmountFieldsStateRef = React.useRef<Record<string, any>>({});\n  const resetFieldArrayFunctionRef = React.useRef({});\n  const contextRef = React.useRef(context);\n  const resolverRef = React.useRef(resolver);\n  const fieldArrayNamesRef = React.useRef<Set<string>>(new Set());\n  const [, render] = React.useState();\n  const { isOnBlur, isOnSubmit, isOnChange, isOnAll } = React.useRef(\n    modeChecker(mode),\n  ).current;\n  const validateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const isWindowUndefined = typeof window === UNDEFINED;\n  const isWeb =\n    typeof document !== UNDEFINED &&\n    !isWindowUndefined &&\n    !isUndefined(window.HTMLElement);\n  const isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n  const readFormStateRef = React.useRef<ReadFormState>({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    isSubmitted: isOnSubmit,\n    submitCount: !isProxyEnabled,\n    touched: !isProxyEnabled,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled,\n  });\n  const {\n    isOnBlur: isReValidateOnBlur,\n    isOnSubmit: isReValidateOnSubmit,\n  } = React.useRef(modeChecker(reValidateMode)).current;\n  contextRef.current = context;\n  resolverRef.current = resolver;\n\n  const reRender = React.useCallback(() => {\n    if (!isUnMount.current) {\n      render({});\n    }\n  }, []);\n\n  const shouldRenderBaseOnError = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      error: FlatFieldErrors<TFieldValues>,\n      shouldRender: boolean | null = false,\n    ): boolean | void => {\n      let shouldReRender =\n        shouldRender ||\n        shouldRenderBasedOnError<TFieldValues>({\n          errors: errorsRef.current,\n          error,\n          name,\n          validFields: validFieldsRef.current,\n          fieldsWithValidation: fieldsWithValidationRef.current,\n        });\n      const previousError = get(errorsRef.current, name);\n\n      if (isEmptyObject(error)) {\n        if (fieldsWithValidationRef.current.has(name) || resolverRef.current) {\n          validFieldsRef.current.add(name);\n          shouldReRender = shouldReRender || previousError;\n        }\n\n        errorsRef.current = unset(errorsRef.current, name);\n      } else {\n        validFieldsRef.current.delete(name);\n        shouldReRender =\n          shouldReRender ||\n          !previousError ||\n          !isSameError(previousError, error[name] as FieldError);\n\n        set(errorsRef.current, name, error[name]);\n      }\n\n      if (shouldReRender && !isNullOrUndefined(shouldRender)) {\n        reRender();\n        return true;\n      }\n    },\n    [reRender, resolverRef],\n  );\n\n  const setFieldValue = React.useCallback(\n    (\n      { ref, options }: Field,\n      rawValue:\n        | FieldValue<TFieldValues>\n        | UnpackNestedValue<DeepPartial<TFieldValues>>\n        | undefined\n        | null\n        | boolean,\n    ) => {\n      const value =\n        isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\n          ? ''\n          : rawValue;\n\n      if (isRadioInput(ref) && options) {\n        options.forEach(\n          ({ ref: radioRef }: { ref: HTMLInputElement }) =>\n            (radioRef.checked = radioRef.value === value),\n        );\n      } else if (isFileInput(ref)) {\n        if (isString(value)) {\n          ref.value = value;\n        } else {\n          ref.files = value as FileList;\n        }\n      } else if (isMultipleSelect(ref)) {\n        [...ref.options].forEach(\n          (selectRef) =>\n            (selectRef.selected = (value as string).includes(selectRef.value)),\n        );\n      } else if (isCheckBoxInput(ref) && options) {\n        options.length > 1\n          ? options.forEach(\n              ({ ref: checkboxRef }) =>\n                (checkboxRef.checked = (value as string).includes(\n                  checkboxRef.value,\n                )),\n            )\n          : (options[0].ref.checked = !!value);\n      } else {\n        ref.value = value;\n      }\n    },\n    [isWeb],\n  );\n\n  const setDirty = React.useCallback(\n    (name: InternalFieldName<TFieldValues>): boolean => {\n      const { isDirty, dirtyFields } = readFormStateRef.current;\n\n      if (!fieldsRef.current[name] || (!isDirty && !dirtyFields)) {\n        return false;\n      }\n\n      const isFieldDirty =\n        defaultValuesAtRenderRef.current[name] !==\n        getFieldValue(fieldsRef.current, name);\n      const isDirtyFieldExist = get(dirtyFieldsRef.current, name);\n      const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n      const previousIsDirty = isDirtyRef.current;\n\n      if (isFieldDirty) {\n        set(dirtyFieldsRef.current, name, true);\n      } else {\n        unset(dirtyFieldsRef.current, name);\n      }\n\n      isDirtyRef.current =\n        (isFieldArray &&\n          getIsFieldsDifferent(\n            getFieldArrayValueByName(\n              fieldsRef.current,\n              getFieldArrayParentName(name),\n            ),\n            get(defaultValuesRef.current, getFieldArrayParentName(name)),\n          )) ||\n        !isEmptyObject(dirtyFieldsRef.current);\n\n      return (\n        (isDirty && previousIsDirty !== isDirtyRef.current) ||\n        (dirtyFields && isDirtyFieldExist !== get(dirtyFieldsRef.current, name))\n      );\n    },\n    [],\n  );\n\n  const executeValidation = React.useCallback(\n    async (\n      name: InternalFieldName<TFieldValues>,\n      skipReRender?: boolean,\n    ): Promise<boolean> => {\n      if (fieldsRef.current[name]) {\n        const error = await validateField<TFieldValues>(\n          fieldsRef,\n          validateAllFieldCriteria,\n          fieldsRef.current[name] as Field,\n        );\n\n        shouldRenderBaseOnError(name, error, skipReRender ? null : false);\n\n        return isEmptyObject(error);\n      }\n\n      return false;\n    },\n    [shouldRenderBaseOnError, validateAllFieldCriteria],\n  );\n\n  const executeSchemaOrResolverValidation = React.useCallback(\n    async (\n      payload:\n        | InternalFieldName<TFieldValues>\n        | InternalFieldName<TFieldValues>[],\n    ) => {\n      const { errors } = await resolverRef.current!(\n        getFieldArrayValueByName(fieldsRef.current),\n        contextRef.current,\n        validateAllFieldCriteria,\n      );\n      const previousFormIsValid = isValidRef.current;\n      isValidRef.current = isEmptyObject(errors);\n\n      if (isArray(payload)) {\n        const isInputsValid = payload\n          .map((name) => {\n            const error = get(errors, name);\n\n            if (error) {\n              set(errorsRef.current, name, error);\n            } else {\n              unset(errorsRef.current, name);\n            }\n\n            return !error;\n          })\n          .every(Boolean);\n\n        reRender();\n\n        return isInputsValid;\n      } else {\n        const error = get(errors, payload);\n\n        shouldRenderBaseOnError(\n          payload,\n          (error ? { [payload]: error } : {}) as FlatFieldErrors<TFieldValues>,\n          previousFormIsValid !== isValidRef.current,\n        );\n\n        return !error;\n      }\n    },\n    [reRender, shouldRenderBaseOnError, validateAllFieldCriteria, resolverRef],\n  );\n\n  const trigger = React.useCallback(\n    async (\n      name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n    ): Promise<boolean> => {\n      const fields = name || Object.keys(fieldsRef.current);\n\n      if (resolverRef.current) {\n        return executeSchemaOrResolverValidation(fields);\n      }\n\n      if (isArray(fields)) {\n        const result = await Promise.all(\n          fields.map(async (data) => await executeValidation(data, true)),\n        );\n        reRender();\n        return result.every(Boolean);\n      }\n\n      return await executeValidation(fields);\n    },\n    [\n      executeSchemaOrResolverValidation,\n      executeValidation,\n      reRender,\n      resolverRef,\n    ],\n  );\n\n  const setInternalValues = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      value: FieldValue<TFieldValues>,\n      config: SetValueConfig,\n      parentFieldName?: string,\n    ) => {\n      for (const key in value) {\n        const fieldName = `${parentFieldName || name}${\n          isArray(value) ? `[${key}]` : `.${key}`\n        }`;\n        const field = fieldsRef.current[fieldName];\n\n        if (isObject(value[key])) {\n          setInternalValues(name, value[key], config, fieldName);\n        }\n\n        if (field) {\n          setFieldValue(field, value[key]);\n\n          if (config.shouldDirty) {\n            setDirty(fieldName);\n          }\n\n          if (config.shouldValidate) {\n            trigger(fieldName as FieldName<TFieldValues>);\n          }\n        }\n      }\n    },\n    [trigger, setFieldValue, setDirty],\n  );\n\n  const setInternalValue = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      value: FieldValue<TFieldValues> | null | undefined | boolean,\n      config: SetValueConfig,\n    ): boolean | void => {\n      if (fieldsRef.current[name]) {\n        setFieldValue(fieldsRef.current[name] as Field, value);\n\n        return config.shouldDirty && setDirty(name);\n      } else if (!isPrimitive(value)) {\n        setInternalValues(name, value, config);\n      }\n    },\n    [setDirty, setFieldValue, setInternalValues],\n  );\n\n  const isFieldWatched = (name: string) =>\n    isWatchAllRef.current ||\n    watchFieldsRef.current.has(name) ||\n    watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const renderWatchedInputs = (name: string, found = true): boolean => {\n    if (!isEmptyObject(watchFieldsHookRef.current)) {\n      for (const key in watchFieldsHookRef.current) {\n        if (\n          watchFieldsHookRef.current[key].has(name) ||\n          !watchFieldsHookRef.current[key].size ||\n          isNameInFieldArray(fieldArrayNamesRef.current, name)\n        ) {\n          watchFieldsHookRenderRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue<\n    TFieldName extends string,\n    TFieldValue extends TFieldValues[TFieldName]\n  >(\n    name: TFieldName,\n    value: NonUndefined<TFieldValue> extends NestedValue<infer U>\n      ? U\n      : UnpackNestedValue<DeepPartial<LiteralToPrimitive<TFieldValue>>>,\n    config: SetValueConfig = {},\n  ): void {\n    const shouldRender =\n      setInternalValue(name, value as TFieldValues[string], config) ||\n      !isPrimitive(value) ||\n      isFieldWatched(name);\n\n    renderWatchedInputs(name);\n\n    if (shouldRender) {\n      reRender();\n    }\n\n    if (config.shouldValidate) {\n      trigger(name as any);\n    }\n  }\n\n  handleChangeRef.current = handleChangeRef.current\n    ? handleChangeRef.current\n    : async ({ type, target }: Event): Promise<void | boolean> => {\n        const name = target ? (target as Ref).name : '';\n        const field = fieldsRef.current[name];\n        let error: FlatFieldErrors<TFieldValues>;\n\n        if (!field) {\n          return;\n        }\n\n        const isBlurEvent = type === EVENTS.BLUR;\n        const shouldSkipValidation =\n          !isOnAll &&\n          skipValidation({\n            hasError: !!get(errorsRef.current, name),\n            isOnChange,\n            isBlurEvent,\n            isOnSubmit,\n            isReValidateOnSubmit,\n            isOnBlur,\n            isReValidateOnBlur,\n            isSubmitted: isSubmittedRef.current,\n          });\n        let shouldRender = setDirty(name) || isFieldWatched(name);\n\n        if (\n          isBlurEvent &&\n          !get(touchedFieldsRef.current, name) &&\n          readFormStateRef.current.touched\n        ) {\n          set(touchedFieldsRef.current, name, true);\n          shouldRender = true;\n        }\n\n        if (shouldSkipValidation) {\n          renderWatchedInputs(name);\n          return shouldRender && reRender();\n        }\n\n        if (resolver) {\n          const { errors } = await resolver(\n            getFieldArrayValueByName(fieldsRef.current),\n            contextRef.current,\n            validateAllFieldCriteria,\n          );\n          const previousFormIsValid = isValidRef.current;\n          isValidRef.current = isEmptyObject(errors);\n\n          error = (get(errors, name)\n            ? { [name]: get(errors, name) }\n            : {}) as FlatFieldErrors<TFieldValues>;\n\n          if (previousFormIsValid !== isValidRef.current) {\n            shouldRender = true;\n          }\n        } else {\n          error = await validateField<TFieldValues>(\n            fieldsRef,\n            validateAllFieldCriteria,\n            field,\n          );\n        }\n\n        renderWatchedInputs(name);\n\n        if (!shouldRenderBaseOnError(name, error) && shouldRender) {\n          reRender();\n        }\n      };\n\n  const validateResolver = React.useCallback(\n    (values: any = {}) => {\n      const fieldValues = isEmptyObject(defaultValuesRef.current)\n        ? getFieldsValues(fieldsRef.current)\n        : defaultValuesRef.current;\n\n      resolverRef.current!(\n        transformToNestObject({\n          ...fieldValues,\n          ...values,\n        }),\n        contextRef.current,\n        validateAllFieldCriteria,\n      ).then(({ errors }) => {\n        const previousFormIsValid = isValidRef.current;\n        isValidRef.current = isEmptyObject(errors);\n\n        if (previousFormIsValid !== isValidRef.current) {\n          reRender();\n        }\n      });\n    },\n    [reRender, validateAllFieldCriteria, resolverRef],\n  );\n\n  const removeFieldEventListener = React.useCallback(\n    (field: Field, forceDelete?: boolean) => {\n      findRemovedFieldAndRemoveListener(\n        fieldsRef.current,\n        handleChangeRef.current!,\n        field,\n        unmountFieldsStateRef,\n        shouldUnregister,\n        forceDelete,\n      );\n    },\n    [shouldUnregister],\n  );\n\n  const removeFieldEventListenerAndRef = React.useCallback(\n    (field: Field | undefined, forceDelete?: boolean) => {\n      if (\n        field &&\n        (!isNameInFieldArray(fieldArrayNamesRef.current, field.ref.name) ||\n          forceDelete)\n      ) {\n        removeFieldEventListener(field, forceDelete);\n\n        if (shouldUnregister) {\n          [\n            errorsRef,\n            touchedFieldsRef,\n            dirtyFieldsRef,\n            defaultValuesAtRenderRef,\n          ].forEach((data) => unset(data.current, field.ref.name));\n          [\n            fieldsWithValidationRef,\n            validFieldsRef,\n            watchFieldsRef,\n          ].forEach((data) => data.current.delete(field.ref.name));\n\n          if (\n            readFormStateRef.current.isValid ||\n            readFormStateRef.current.touched\n          ) {\n            reRender();\n\n            if (resolverRef.current) {\n              validateResolver();\n            }\n          }\n        }\n      }\n    },\n    [reRender, validateResolver, removeFieldEventListener, resolverRef],\n  );\n\n  function clearErrors(\n    name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n  ): void {\n    if (name) {\n      (isArray(name) ? name : [name]).forEach((inputName) =>\n        unset(errorsRef.current, inputName),\n      );\n    } else {\n      errorsRef.current = {};\n    }\n\n    reRender();\n  }\n\n  function setError(name: FieldName<TFieldValues>, error: ErrorOption): void {\n    isValidRef.current = false;\n\n    set(errorsRef.current, name, {\n      ...error,\n      ref: (fieldsRef.current[name] || {})!.ref,\n    });\n\n    reRender();\n  }\n\n  const watchInternal = React.useCallback(\n    (\n      fieldNames?: string | string[],\n      defaultValue?: unknown,\n      watchId?: string,\n    ) => {\n      const watchFields = watchId\n        ? watchFieldsHookRef.current[watchId]\n        : watchFieldsRef.current;\n      const combinedDefaultValues = isUndefined(defaultValue)\n        ? defaultValuesRef.current\n        : defaultValue;\n      const fieldValues = getFieldsValues<TFieldValues>(\n        fieldsRef.current,\n        fieldNames,\n      );\n\n      if (isString(fieldNames)) {\n        return assignWatchFields<TFieldValues>(\n          fieldValues,\n          fieldNames,\n          watchFields,\n          isUndefined(defaultValue)\n            ? get(combinedDefaultValues, fieldNames)\n            : (defaultValue as UnpackNestedValue<DeepPartial<TFieldValues>>),\n          true,\n        );\n      }\n\n      if (isArray(fieldNames)) {\n        return fieldNames.reduce(\n          (previous, name) => ({\n            ...previous,\n            [name]: assignWatchFields<TFieldValues>(\n              fieldValues,\n              name,\n              watchFields,\n              combinedDefaultValues as UnpackNestedValue<\n                DeepPartial<TFieldValues>\n              >,\n            ),\n          }),\n          {},\n        );\n      }\n\n      if (isUndefined(watchId)) {\n        isWatchAllRef.current = true;\n      }\n\n      return transformToNestObject(\n        (!isEmptyObject(fieldValues) && fieldValues) ||\n          (combinedDefaultValues as FieldValues),\n      );\n    },\n    [],\n  );\n\n  function watch(): UnpackNestedValue<TFieldValues>;\n  function watch<\n    TFieldName extends string,\n    TFieldValue extends TFieldValues[TFieldName]\n  >(\n    name: TFieldName,\n    defaultValue?: UnpackNestedValue<LiteralToPrimitive<TFieldValue>>,\n  ): UnpackNestedValue<LiteralToPrimitive<TFieldValue>>;\n  function watch<TFieldName extends keyof TFieldValues>(\n    names: TFieldName[],\n    defaultValues?: UnpackNestedValue<\n      DeepPartial<Pick<TFieldValues, TFieldName>>\n    >,\n  ): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;\n  function watch(\n    names: string[],\n    defaultValues?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  ): UnpackNestedValue<DeepPartial<TFieldValues>>;\n  function watch(\n    fieldNames?: string | string[],\n    defaultValue?: unknown,\n  ): unknown {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(\n    name: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n  ): void {\n    (isArray(name) ? name : [name]).forEach((fieldName) =>\n      removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true),\n    );\n  }\n\n  function registerFieldsRef<TFieldElement extends FieldElement<TFieldValues>>(\n    ref: TFieldElement & Ref,\n    validateOptions: ValidationRules | null = {},\n  ): ((name: InternalFieldName<TFieldValues>) => void) | void {\n    if (!ref.name) {\n      // eslint-disable-next-line no-console\n      return console.warn('Missing name @', ref);\n    }\n\n    const { name, type, value } = ref;\n    const fieldRefAndValidationOptions = {\n      ref,\n      ...validateOptions,\n    };\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n    let field = fields[name] as Field;\n    let isEmptyDefaultValue = true;\n    let isFieldArray;\n    let defaultValue;\n\n    if (\n      field &&\n      (isRadioOrCheckbox\n        ? isArray(field.options) &&\n          unique(field.options).find((option) => {\n            return value === option.ref.value && option.ref === ref;\n          })\n        : ref === field.ref)\n    ) {\n      fields[name] = {\n        ...field,\n        ...validateOptions,\n      };\n      return;\n    }\n\n    if (type) {\n      const mutationWatcher = onDomRemove(ref, () =>\n        removeFieldEventListenerAndRef(field),\n      );\n\n      field = isRadioOrCheckbox\n        ? {\n            options: [\n              ...unique((field && field.options) || []),\n              {\n                ref,\n                mutationWatcher,\n              } as RadioOrCheckboxOption,\n            ],\n            ref: { type, name },\n            ...validateOptions,\n          }\n        : {\n            ...fieldRefAndValidationOptions,\n            mutationWatcher,\n          };\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n\n    const isEmptyUnmountFields = isUndefined(\n      unmountFieldsStateRef.current[name],\n    );\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = isEmptyUnmountFields\n        ? get(defaultValuesRef.current, name)\n        : unmountFieldsStateRef.current[name];\n      isEmptyDefaultValue = isUndefined(defaultValue);\n      isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(field, defaultValue);\n      }\n    }\n\n    if (resolver && !isFieldArray && readFormStateRef.current.isValid) {\n      validateResolver();\n    } else if (!isEmptyObject(validateOptions)) {\n      fieldsWithValidationRef.current.add(name);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(fieldsRef, validateAllFieldCriteria, field).then(\n          (error) => {\n            const previousFormIsValid = isValidRef.current;\n\n            isEmptyObject(error)\n              ? validFieldsRef.current.add(name)\n              : (isValidRef.current = false);\n\n            if (previousFormIsValid !== isValidRef.current) {\n              reRender();\n            }\n          },\n        );\n      }\n    }\n\n    if (\n      !defaultValuesAtRenderRef.current[name] &&\n      !(isFieldArray && isEmptyDefaultValue)\n    ) {\n      defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue\n        ? getFieldValue(fields, name)\n        : defaultValue;\n    }\n\n    if (type) {\n      attachEventListeners({\n        field:\n          isRadioOrCheckbox && field.options\n            ? field.options[field.options.length - 1]\n            : field,\n        isRadioOrCheckbox:\n          isRadioOrCheckbox || isSelectInput(ref as FieldElement),\n        handleChange: handleChangeRef.current,\n      });\n    }\n  }\n\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    rules?: ValidationRules,\n  ): (ref: (TFieldElement & Ref) | null) => void;\n  function register(\n    name: FieldName<TFieldValues>,\n    rules?: ValidationRules,\n  ): void;\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    ref: (TFieldElement & Ref) | null,\n    rules?: ValidationRules,\n  ): void;\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    refOrValidationOptions?:\n      | FieldName<TFieldValues>\n      | ValidationRules\n      | (TFieldElement & Ref)\n      | null,\n    rules?: ValidationRules,\n  ): ((ref: (TFieldElement & Ref) | null) => void) | void {\n    if (!isWindowUndefined) {\n      if (isString(refOrValidationOptions)) {\n        registerFieldsRef({ name: refOrValidationOptions }, rules);\n      } else if (\n        isObject(refOrValidationOptions) &&\n        'name' in refOrValidationOptions\n      ) {\n        registerFieldsRef(refOrValidationOptions, rules);\n      } else {\n        return (ref: (TFieldElement & Ref) | null) =>\n          ref && registerFieldsRef(ref, refOrValidationOptions);\n      }\n    }\n  }\n\n  const handleSubmit = React.useCallback(\n    <TSubmitFieldValues extends FieldValues = TFieldValues>(\n      callback: SubmitHandler<TSubmitFieldValues>,\n    ) => async (e?: React.BaseSyntheticEvent): Promise<void> => {\n      if (e) {\n        e.preventDefault();\n        e.persist();\n      }\n      let fieldErrors: FieldErrors<TFieldValues> = {};\n      let fieldValues: FieldValues = {\n        ...unmountFieldsStateRef.current,\n        ...getFieldsValues(fieldsRef.current),\n      };\n\n      if (readFormStateRef.current.isSubmitting) {\n        isSubmittingRef.current = true;\n        reRender();\n      }\n\n      try {\n        if (resolverRef.current) {\n          const { errors, values } = await resolverRef.current(\n            transformToNestObject(fieldValues),\n            contextRef.current,\n            validateAllFieldCriteria,\n          );\n          errorsRef.current = errors;\n          fieldErrors = errors;\n          fieldValues = values;\n        } else {\n          for (const field of Object.values(fieldsRef.current)) {\n            if (field) {\n              const {\n                ref: { name },\n              } = field;\n\n              const fieldError = await validateField(\n                fieldsRef,\n                validateAllFieldCriteria,\n                field,\n              );\n\n              if (fieldError[name]) {\n                set(fieldErrors, name, fieldError[name]);\n                validFieldsRef.current.delete(name);\n              } else if (fieldsWithValidationRef.current.has(name)) {\n                validFieldsRef.current.add(name);\n              }\n            }\n          }\n        }\n\n        if (\n          isEmptyObject(fieldErrors) &&\n          Object.keys(errorsRef.current).every((name) =>\n            Object.keys(fieldsRef.current).includes(name),\n          )\n        ) {\n          errorsRef.current = {};\n          reRender();\n          await callback(transformToNestObject(fieldValues), e);\n        } else {\n          errorsRef.current = {\n            ...errorsRef.current,\n            ...fieldErrors,\n          };\n          if (shouldFocusError && isWeb) {\n            focusOnErrorField(fieldsRef.current, fieldErrors);\n          }\n        }\n      } finally {\n        isSubmittedRef.current = true;\n        isSubmittingRef.current = false;\n        submitCountRef.current = submitCountRef.current + 1;\n        reRender();\n      }\n    },\n    [isWeb, reRender, resolverRef, shouldFocusError, validateAllFieldCriteria],\n  );\n\n  const resetRefs = ({\n    errors,\n    isDirty,\n    isSubmitted,\n    touched,\n    isValid,\n    submitCount,\n    dirtyFields,\n  }: OmitResetState) => {\n    fieldsRef.current = {};\n    if (!errors) {\n      errorsRef.current = {};\n    }\n\n    if (!touched) {\n      touchedFieldsRef.current = {};\n    }\n\n    if (!isValid) {\n      validFieldsRef.current = new Set();\n      fieldsWithValidationRef.current = new Set();\n      isValidRef.current = true;\n    }\n\n    if (!isDirty) {\n      isDirtyRef.current = false;\n    }\n\n    if (!dirtyFields) {\n      dirtyFieldsRef.current = {};\n    }\n\n    if (!isSubmitted) {\n      isSubmittedRef.current = false;\n    }\n\n    if (!submitCount) {\n      submitCountRef.current = 0;\n    }\n\n    defaultValuesAtRenderRef.current = {} as DefaultValuesAtRender<\n      TFieldValues\n    >;\n    fieldArrayDefaultValues.current = {};\n    unmountFieldsStateRef.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n  };\n\n  const reset = (\n    values?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n    omitResetState: OmitResetState = {},\n  ): void => {\n    if (isWeb) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field) {\n          const { ref, options } = field;\n          const inputRef =\n            isRadioOrCheckboxFunction(ref) && isArray(options)\n              ? options[0].ref\n              : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form')!.reset();\n              break;\n            } catch {}\n          }\n        }\n      }\n    }\n\n    if (values) {\n      defaultValuesRef.current = values;\n    }\n\n    Object.values(resetFieldArrayFunctionRef.current).forEach(\n      (resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray(),\n    );\n\n    resetRefs(omitResetState);\n\n    reRender();\n  };\n\n  const getValue = <TFieldName extends string, TFieldValue extends unknown>(\n    name: TFieldName,\n  ): TFieldName extends keyof TFieldValues\n    ? UnpackNestedValue<TFieldValues>[TFieldName]\n    : TFieldValue => getFieldValue(fieldsRef.current, name);\n\n  function getValues(): UnpackNestedValue<TFieldValues>;\n  function getValues<TFieldName extends string, TFieldValue extends unknown>(\n    name: TFieldName,\n  ): TFieldName extends keyof TFieldValues\n    ? UnpackNestedValue<TFieldValues>[TFieldName]\n    : TFieldValue;\n  function getValues<TFieldName extends keyof TFieldValues>(\n    names: TFieldName[],\n  ): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;\n  function getValues(payload?: string | string[]): unknown {\n    const fields = fieldsRef.current;\n\n    if (isString(payload)) {\n      return getValue(payload);\n    }\n\n    if (isArray(payload)) {\n      return payload.reduce(\n        (previous, name) => ({\n          ...previous,\n          [name]: getValue(name),\n        }),\n        {},\n      );\n    }\n\n    return transformToNestObject(getFieldsValues(fields));\n  }\n\n  React.useEffect(() => {\n    isUnMount.current = false;\n\n    return () => {\n      isUnMount.current = true;\n      fieldsRef.current &&\n        process.env.NODE_ENV === 'production' &&\n        Object.values(fieldsRef.current).forEach((field) =>\n          removeFieldEventListenerAndRef(field, true),\n        );\n    };\n  }, [removeFieldEventListenerAndRef]);\n\n  if (!resolver) {\n    isValidRef.current =\n      validFieldsRef.current.size >= fieldsWithValidationRef.current.size &&\n      isEmptyObject(errorsRef.current);\n  }\n\n  const formState = {\n    dirtyFields: dirtyFieldsRef.current,\n    isSubmitted: isSubmittedRef.current,\n    submitCount: submitCountRef.current,\n    touched: touchedFieldsRef.current,\n    isDirty: isDirtyRef.current,\n    isSubmitting: isSubmittingRef.current,\n    isValid: isOnSubmit\n      ? isSubmittedRef.current && isEmptyObject(errorsRef.current)\n      : isValidRef.current,\n  };\n\n  const commonProps = {\n    trigger,\n    setValue: React.useCallback(setValue, [\n      reRender,\n      setInternalValue,\n      trigger,\n    ]),\n    getValues: React.useCallback(getValues, []),\n    register: React.useCallback(register, [defaultValuesRef.current]),\n    unregister: React.useCallback(unregister, []),\n    formState: isProxyEnabled\n      ? new Proxy<FormStateProxy<TFieldValues>>(formState, {\n          get: (obj, prop: keyof FormStateProxy) => {\n            if (prop in obj) {\n              readFormStateRef.current[prop] = true;\n              return obj[prop];\n            }\n\n            return undefined;\n          },\n        })\n      : formState,\n  };\n\n  const control = {\n    removeFieldEventListener,\n    renderWatchedInputs,\n    watchInternal,\n    reRender,\n    ...(resolver ? { validateSchemaIsValid: validateResolver } : {}),\n    mode: {\n      isOnBlur,\n      isOnSubmit,\n      isOnChange,\n    },\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnSubmit,\n    },\n    errorsRef,\n    touchedFieldsRef,\n    fieldsRef,\n    isWatchAllRef,\n    watchFieldsRef,\n    resetFieldArrayFunctionRef,\n    watchFieldsHookRef,\n    watchFieldsHookRenderRef,\n    fieldArrayDefaultValues,\n    validFieldsRef,\n    dirtyFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayNamesRef,\n    isDirtyRef,\n    isSubmittedRef,\n    readFormStateRef,\n    defaultValuesRef,\n    unmountFieldsStateRef,\n    ...commonProps,\n  };\n\n  return {\n    watch,\n    control,\n    handleSubmit,\n    reset: React.useCallback(reset, []),\n    clearErrors: React.useCallback(clearErrors, []),\n    setError: React.useCallback(setError, []),\n    errors: errorsRef.current,\n    ...commonProps,\n  };\n}\n","import * as React from 'react';\nimport { UseFormMethods, FieldValues } from './types/form';\nimport { FormProviderProps } from './types/props';\n\nexport const FormContext = React.createContext<UseFormMethods | null>(null);\n\nFormContext.displayName = 'RHFContext';\n\nexport const useFormContext = <\n  TFieldValues extends FieldValues\n>(): UseFormMethods<TFieldValues> =>\n  React.useContext(FormContext) as UseFormMethods<TFieldValues>;\n\nexport const FormProvider = <TFieldValues extends FieldValues>({\n  children,\n  ...props\n}: FormProviderProps<TFieldValues>) => (\n  <FormContext.Provider value={{ ...props } as UseFormMethods}>\n    {children}\n  </FormContext.Provider>\n);\n","import { UNDEFINED } from '../constants';\n\nexport default () => {\n  const d =\n    typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n};\n","import isArray from '../utils/isArray';\nimport isObject from '../utils/isObject';\nimport generateId from './generateId';\nimport { ArrayField } from '../types/form';\n\nexport const appendId = <TValue extends object, TKeyName extends string>(\n  value: TValue,\n  keyName: TKeyName,\n): Partial<ArrayField<TValue, TKeyName>> => ({\n  [keyName]: generateId(),\n  ...(isObject(value) ? value : { value }),\n});\n\nexport const mapIds = <TData extends object, TKeyName extends string>(\n  data: TData | TData[],\n  keyName: TKeyName,\n) => (isArray(data) ? data : []).map((value) => appendId(value, keyName));\n","import isUndefined from './isUndefined';\nimport isArray from './isArray';\nimport unique from './unique';\n\nconst removeAt = <T>(data: T[], index: number): T[] => [\n  ...data.slice(0, index),\n  ...data.slice(index + 1),\n];\n\nfunction removeAtIndexes<T>(data: T[], index: number[]): T[] {\n  let k = -1;\n\n  while (++k < data.length) {\n    if (index.indexOf(k) >= 0) {\n      delete data[k];\n    }\n  }\n\n  return unique(data);\n}\n\nexport default <T>(data: T[], index?: number | number[]): T[] =>\n  isUndefined(index)\n    ? []\n    : isArray(index)\n    ? removeAtIndexes(data, index)\n    : removeAt(data, index);\n","import isArray from './isArray';\n\nexport default <T>(data: T[], from: number, to: number): T[] =>\n  isArray(data) ? data.splice(to, 0, data.splice(from, 1)[0]) : [];\n","export default <T>(data: T[], indexA: number, indexB: number): void => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n","import isArray from './isArray';\n\nexport default function prepend<T>(data: T[]): (T | null)[];\nexport default function prepend<T>(data: T[], value: T | T[]): T[];\nexport default function prepend<T>(data: T[], value?: T | T[]): (T | null)[] {\n  return [...(isArray(value) ? value : [value || null]), ...data];\n}\n","import isArray from './isArray';\n\nexport default function insert<T>(data: T[], index: number): (T | null)[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value: T | T[],\n): T[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value?: T | T[],\n): (T | null)[] {\n  return [\n    ...data.slice(0, index),\n    ...(isArray(value) ? value : [value || null]),\n    ...data.slice(index),\n  ];\n}\n","import isArray from './isArray';\n\nexport default <T>(value: T | T[]): null[] | null =>\n  isArray(value) ? Array(value.length).fill(null) : null;\n","import isArray from './isArray';\nimport isObject from './isObject';\n\nfunction mapValueToBoolean(value: any) {\n  if (isObject(value)) {\n    const object: any = {};\n\n    for (const key in value) {\n      object[key] = true;\n    }\n\n    return [object];\n  }\n\n  return [true];\n}\n\nexport const filterBooleanArray = <T>(value: T): T[] =>\n  isArray(value)\n    ? value.map(mapValueToBoolean).flat()\n    : mapValueToBoolean(value);\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport { isMatchFieldArrayName } from './logic/isNameInFieldArray';\nimport getFieldValueByName from './logic/getFieldArrayValueByName';\nimport { appendId, mapIds } from './logic/mapIds';\nimport getIsFieldsDifferent from './logic/getIsFieldsDifferent';\nimport getFieldArrayParentName from './logic/getFieldArrayParentName';\nimport get from './utils/get';\nimport isUndefined from './utils/isUndefined';\nimport removeArrayAt from './utils/remove';\nimport moveArrayAt from './utils/move';\nimport swapArrayAt from './utils/swap';\nimport prependAt from './utils/prepend';\nimport isArray from './utils/isArray';\nimport insertAt from './utils/insert';\nimport isKey from './utils/isKey';\nimport fillEmptyArray from './utils/fillEmptyArray';\nimport { filterBooleanArray } from './utils/filterBooleanArray';\nimport unique from './utils/unique';\nimport {\n  Field,\n  FieldValues,\n  UseFieldArrayOptions,\n  Control,\n  ArrayField,\n} from './types/form';\n\nexport const useFieldArray = <\n  TFieldArrayValues extends FieldValues = FieldValues,\n  TKeyName extends string = 'id',\n  TControl extends Control = Control\n>({\n  control,\n  name,\n  keyName = 'id' as TKeyName,\n}: UseFieldArrayOptions<TKeyName, TControl>) => {\n  const methods = useFormContext();\n  const focusIndexRef = React.useRef(-1);\n  const {\n    isWatchAllRef,\n    resetFieldArrayFunctionRef,\n    fieldArrayNamesRef,\n    reRender,\n    fieldsRef,\n    defaultValuesRef,\n    removeFieldEventListener,\n    errorsRef,\n    dirtyFieldsRef,\n    isDirtyRef,\n    touchedFieldsRef,\n    readFormStateRef,\n    watchFieldsRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValues,\n    validateSchemaIsValid,\n    renderWatchedInputs,\n  } = control || methods.control;\n  let shouldRender;\n\n  const getDefaultValues = () => [\n    ...get(\n      fieldArrayDefaultValues.current[getFieldArrayParentName(name)]\n        ? fieldArrayDefaultValues.current\n        : defaultValuesRef.current,\n      name,\n      [],\n    ),\n  ];\n  const memoizedDefaultValues = React.useRef<Partial<TFieldArrayValues>[]>(\n    getDefaultValues(),\n  );\n  const [fields, setField] = React.useState<\n    Partial<ArrayField<TFieldArrayValues, TKeyName>>[]\n  >(mapIds(memoizedDefaultValues.current, keyName));\n  const [isDeleted, setIsDeleted] = React.useState(false);\n  const allFields = React.useRef<\n    Partial<ArrayField<TFieldArrayValues, TKeyName>>[]\n  >(fields);\n  const isNameKey = isKey(name);\n\n  allFields.current = fields;\n\n  if (isNameKey) {\n    fieldArrayDefaultValues.current[name] = memoizedDefaultValues.current;\n  }\n\n  const appendValueWithKey = (values: Partial<TFieldArrayValues>[]) =>\n    values.map((value: Partial<TFieldArrayValues>) => appendId(value, keyName));\n\n  const setFieldAndValidState = (\n    fieldsValues: Partial<ArrayField<TFieldArrayValues, TKeyName>>[],\n  ) => {\n    setField(fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateSchemaIsValid) {\n      validateSchemaIsValid({\n        [name]: fieldsValues,\n      });\n    }\n  };\n\n  const shouldRenderFieldArray = (shouldRender: boolean) => {\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      shouldRender = true;\n    }\n\n    renderWatchedInputs(name);\n\n    shouldRender && !isWatchAllRef.current && reRender();\n  };\n\n  const resetFields = (\n    flagOrFields?: (Partial<TFieldArrayValues> | null)[],\n  ) => {\n    if (readFormStateRef.current.isDirty) {\n      isDirtyRef.current =\n        isUndefined(flagOrFields) ||\n        getIsFieldsDifferent(\n          flagOrFields,\n          get(defaultValuesRef.current, name, []),\n        );\n    }\n\n    for (const key in fieldsRef.current) {\n      if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\n        removeFieldEventListener(fieldsRef.current[key] as Field, true);\n      }\n    }\n  };\n\n  const append = (\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    shouldRender = false;\n    setFieldAndValidState([\n      ...allFields.current,\n      ...(isArray(value)\n        ? appendValueWithKey(value)\n        : [appendId(value, keyName)]),\n    ]);\n\n    if (readFormStateRef.current.dirtyFields) {\n      dirtyFieldsRef.current[name] = [\n        ...(dirtyFieldsRef.current[name] || fillEmptyArray(fields.slice(0, 1))),\n        ...filterBooleanArray(value),\n      ];\n      isDirtyRef.current = true;\n      shouldRender = true;\n    }\n\n    focusIndexRef.current = shouldFocus ? allFields.current.length : -1;\n\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const prepend = (\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const emptyArray = fillEmptyArray(value);\n    shouldRender = false;\n\n    resetFields();\n    setFieldAndValidState(\n      prependAt(\n        allFields.current,\n        isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)],\n      ),\n    );\n\n    if (isArray(get(errorsRef.current, name))) {\n      errorsRef.current[name] = prependAt(\n        get(errorsRef.current, name),\n        emptyArray,\n      );\n    }\n\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      touchedFieldsRef.current[name] = prependAt(\n        touchedFieldsRef.current[name],\n        emptyArray,\n      );\n      shouldRender = true;\n    }\n\n    if (\n      (readFormStateRef.current.dirtyFields ||\n        readFormStateRef.current.isDirty) &&\n      dirtyFieldsRef.current[name]\n    ) {\n      dirtyFieldsRef.current[name] = prependAt(\n        dirtyFieldsRef.current[name],\n        filterBooleanArray(value),\n      );\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  const remove = (index?: number | number[]) => {\n    shouldRender = false;\n\n    resetFields(\n      removeArrayAt(getFieldValueByName(fieldsRef.current, name), index),\n    );\n    setFieldAndValidState(removeArrayAt(allFields.current, index));\n    setIsDeleted(true);\n\n    if (isArray(get(errorsRef.current, name))) {\n      errorsRef.current[name] = removeArrayAt(\n        get(errorsRef.current, name),\n        index,\n      );\n      if (!unique(errorsRef.current[name]).length) {\n        delete errorsRef.current[name];\n      }\n    }\n\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      touchedFieldsRef.current[name] = removeArrayAt(\n        touchedFieldsRef.current[name],\n        index,\n      );\n      shouldRender = true;\n    }\n\n    if (\n      (readFormStateRef.current.dirtyFields ||\n        readFormStateRef.current.isDirty) &&\n      dirtyFieldsRef.current[name]\n    ) {\n      dirtyFieldsRef.current[name] = removeArrayAt(\n        dirtyFieldsRef.current[name],\n        index,\n      );\n\n      if (!dirtyFieldsRef.current[name].length) {\n        delete dirtyFieldsRef.current[name];\n      }\n\n      shouldRender = true;\n    }\n\n    if (readFormStateRef.current.isValid && !validateSchemaIsValid) {\n      let fieldIndex = -1;\n      let isFound = false;\n      const isIndexUndefined = isUndefined(index);\n\n      while (fieldIndex++ < fields.length) {\n        const isLast = fieldIndex === fields.length - 1;\n        const isCurrentIndex =\n          (isArray(index) ? index : [index]).indexOf(fieldIndex) >= 0;\n\n        if (isCurrentIndex || isIndexUndefined) {\n          isFound = true;\n        }\n\n        if (!isFound) {\n          continue;\n        }\n\n        for (const key in fields[fieldIndex]) {\n          const currentFieldName = `${name}[${fieldIndex}].${key}`;\n\n          if (isCurrentIndex || isLast || isIndexUndefined) {\n            validFieldsRef.current.delete(currentFieldName);\n            fieldsWithValidationRef.current.delete(currentFieldName);\n          } else {\n            const previousFieldName = `${name}[${fieldIndex - 1}].${key}`;\n\n            if (validFieldsRef.current.has(currentFieldName)) {\n              validFieldsRef.current.add(previousFieldName);\n            }\n            if (fieldsWithValidationRef.current.has(currentFieldName)) {\n              fieldsWithValidationRef.current.add(previousFieldName);\n            }\n          }\n        }\n      }\n    }\n\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const insert = (\n    index: number,\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    shouldRender = false;\n    const emptyArray = fillEmptyArray(value);\n\n    resetFields(insertAt(getFieldValueByName(fieldsRef.current, name), index));\n    setFieldAndValidState(\n      insertAt(\n        allFields.current,\n        index,\n        isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)],\n      ),\n    );\n\n    if (isArray(get(errorsRef.current, name))) {\n      errorsRef.current[name] = insertAt(\n        get(errorsRef.current, name),\n        index,\n        emptyArray,\n      );\n    }\n\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      touchedFieldsRef.current[name] = insertAt(\n        touchedFieldsRef.current[name],\n        index,\n        emptyArray,\n      );\n      shouldRender = true;\n    }\n\n    if (\n      (readFormStateRef.current.dirtyFields ||\n        readFormStateRef.current.isDirty) &&\n      dirtyFieldsRef.current[name]\n    ) {\n      dirtyFieldsRef.current[name] = insertAt(\n        dirtyFieldsRef.current[name],\n        index,\n        filterBooleanArray(value),\n      );\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  const swap = (indexA: number, indexB: number) => {\n    shouldRender = false;\n\n    const fieldValues = getFieldValueByName(fieldsRef.current, name);\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields(fieldValues);\n    swapArrayAt(allFields.current, indexA, indexB);\n    setFieldAndValidState([...allFields.current]);\n\n    if (isArray(get(errorsRef.current, name))) {\n      swapArrayAt(get(errorsRef.current, name), indexA, indexB);\n    }\n\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      swapArrayAt(touchedFieldsRef.current[name], indexA, indexB);\n      shouldRender = true;\n    }\n\n    if (\n      (readFormStateRef.current.dirtyFields ||\n        readFormStateRef.current.isDirty) &&\n      dirtyFieldsRef.current[name]\n    ) {\n      swapArrayAt(dirtyFieldsRef.current[name], indexA, indexB);\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const move = (from: number, to: number) => {\n    shouldRender = false;\n    const fieldValues = getFieldValueByName(fieldsRef.current, name);\n    moveArrayAt(fieldValues, from, to);\n    resetFields(fieldValues);\n    moveArrayAt(allFields.current, from, to);\n    setFieldAndValidState([...allFields.current]);\n\n    if (isArray(get(errorsRef.current, name))) {\n      moveArrayAt(get(errorsRef.current, name), from, to);\n    }\n\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      moveArrayAt(touchedFieldsRef.current[name], from, to);\n      shouldRender = true;\n    }\n\n    if (\n      (readFormStateRef.current.dirtyFields ||\n        readFormStateRef.current.isDirty) &&\n      dirtyFieldsRef.current[name]\n    ) {\n      moveArrayAt(dirtyFieldsRef.current[name], from, to);\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const reset = () => {\n    resetFields();\n    memoizedDefaultValues.current = getDefaultValues();\n    setField(mapIds(memoizedDefaultValues.current, keyName));\n  };\n\n  React.useEffect(() => {\n    if (\n      isNameKey &&\n      isDeleted &&\n      fieldArrayDefaultValues.current[name] &&\n      fields.length < fieldArrayDefaultValues.current[name].length\n    ) {\n      fieldArrayDefaultValues.current[name].pop();\n    }\n\n    if (isWatchAllRef && isWatchAllRef.current) {\n      reRender();\n    } else if (watchFieldsRef) {\n      for (const watchField of watchFieldsRef.current) {\n        if (watchField.startsWith(name)) {\n          reRender();\n          break;\n        }\n      }\n    }\n\n    if (focusIndexRef.current > -1) {\n      for (const key in fieldsRef.current) {\n        const field = fieldsRef.current[key];\n        if (\n          key.startsWith(`${name}[${focusIndexRef.current}]`) &&\n          field!.ref.focus\n        ) {\n          field!.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [\n    fields,\n    name,\n    fieldArrayDefaultValues,\n    isDeleted,\n    isNameKey,\n    reRender,\n    fieldsRef,\n    watchFieldsRef,\n    isWatchAllRef,\n  ]);\n\n  React.useEffect(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    const fieldArrayNames = fieldArrayNamesRef.current;\n    fieldArrayNames.add(name);\n    resetFunctions[name] = reset;\n\n    return () => {\n      resetFields();\n      delete resetFunctions[name];\n      fieldArrayNames.delete(name);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    swap: React.useCallback(swap, [name]),\n    move: React.useCallback(move, [name]),\n    prepend: React.useCallback(prepend, [name]),\n    append: React.useCallback(append, [name]),\n    remove: React.useCallback(remove, [fields, name]),\n    insert: React.useCallback(insert, [name]),\n    fields,\n  };\n};\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport isUndefined from './utils/isUndefined';\nimport isString from './utils/isString';\nimport generateId from './logic/generateId';\nimport get from './utils/get';\nimport isArray from './utils/isArray';\nimport {\n  UseWatchOptions,\n  FieldValues,\n  UnpackNestedValue,\n  Control,\n} from './types/form';\nimport { LiteralToPrimitive, DeepPartial } from './types/utils';\n\nexport function useWatch<TWatchFieldValues extends FieldValues>(props: {\n  defaultValue?: UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\n  control?: Control;\n}): UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\nexport function useWatch<TWatchFieldValue extends any>(props: {\n  name: string;\n  control?: Control;\n}): undefined | UnpackNestedValue<LiteralToPrimitive<TWatchFieldValue>>;\nexport function useWatch<TWatchFieldValue extends any>(props: {\n  name: string;\n  defaultValue: UnpackNestedValue<LiteralToPrimitive<TWatchFieldValue>>;\n  control?: Control;\n}): UnpackNestedValue<LiteralToPrimitive<TWatchFieldValue>>;\nexport function useWatch<TWatchFieldValues extends FieldValues>(props: {\n  name: string[];\n  defaultValue?: UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\n  control?: Control;\n}): UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\nexport function useWatch<TWatchFieldValues>({\n  control,\n  name,\n  defaultValue,\n}: UseWatchOptions): TWatchFieldValues {\n  const methods = useFormContext();\n  const {\n    watchFieldsHookRef,\n    watchFieldsHookRenderRef,\n    watchInternal,\n    defaultValuesRef,\n  } = control || methods.control;\n  const [value, setValue] = React.useState<unknown>(\n    isUndefined(defaultValue)\n      ? isString(name)\n        ? get(defaultValuesRef.current, name)\n        : isArray(name)\n        ? name.reduce(\n            (previous, inputName) => ({\n              ...previous,\n              [inputName]: get(defaultValuesRef.current, inputName),\n            }),\n            {},\n          )\n        : defaultValuesRef.current\n      : defaultValue,\n  );\n  const idRef = React.useRef<string>();\n  const defaultValueRef = React.useRef(defaultValue);\n  const nameRef = React.useRef(name);\n\n  const updateWatchValue = React.useCallback(\n    () =>\n      setValue(\n        watchInternal(nameRef.current, defaultValueRef.current, idRef.current),\n      ),\n    [setValue, watchInternal, defaultValueRef, nameRef, idRef],\n  );\n\n  React.useEffect(() => {\n    const id = (idRef.current = generateId());\n    const watchFieldsHookRender = watchFieldsHookRenderRef.current;\n    const watchFieldsHook = watchFieldsHookRef.current;\n    watchFieldsHook[id] = new Set();\n    watchFieldsHookRender[id] = updateWatchValue;\n    watchInternal(nameRef.current, defaultValueRef.current, id);\n\n    return () => {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [\n    nameRef,\n    updateWatchValue,\n    watchFieldsHookRenderRef,\n    watchFieldsHookRef,\n    watchInternal,\n    defaultValueRef,\n  ]);\n\n  return (isUndefined(value) ? defaultValue : value) as TWatchFieldValues;\n}\n","import isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport isPrimitive from '../utils/isPrimitive';\n\nexport default (event: any, isCheckboxInput: boolean) =>\n  isPrimitive(event) ||\n  !isObject(event.target) ||\n  (isObject(event.target) && !event.type)\n    ? event\n    : isCheckboxInput || isUndefined(event.target.value)\n    ? event.target.checked\n    : event.target.value;\n","import * as React from 'react';\nimport isBoolean from './utils/isBoolean';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport set from './utils/set';\nimport getInputValue from './logic/getInputValue';\nimport skipValidation from './logic/skipValidation';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport { useFormContext } from './useFormContext';\nimport { VALUE } from './constants';\nimport { Control } from './types/form';\nimport { ControllerProps } from './types/props';\n\nconst Controller = <\n  TAs extends\n    | React.ReactElement\n    | React.ComponentType<any>\n    | 'input'\n    | 'select'\n    | 'textarea',\n  TControl extends Control = Control\n>({\n  name,\n  rules,\n  as,\n  render,\n  defaultValue,\n  control,\n  onFocus,\n  ...rest\n}: ControllerProps<TAs, TControl>) => {\n  const methods = useFormContext();\n  const {\n    defaultValuesRef,\n    setValue,\n    register,\n    unregister,\n    errorsRef,\n    trigger,\n    mode: { isOnSubmit, isOnBlur, isOnChange },\n    reValidateMode: { isReValidateOnBlur, isReValidateOnSubmit },\n    isSubmittedRef,\n    touchedFieldsRef,\n    readFormStateRef,\n    reRender,\n    fieldsRef,\n    fieldArrayNamesRef,\n    unmountFieldsStateRef,\n    formState,\n  } = control || methods.control;\n  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n  const getInitialValue = () =>\n    !isUndefined(unmountFieldsStateRef.current[name]) && isNotFieldArray\n      ? unmountFieldsStateRef.current[name]\n      : isUndefined(defaultValue)\n      ? get(defaultValuesRef.current, name)\n      : defaultValue;\n  const [value, setInputStateValue] = React.useState(getInitialValue());\n  const valueRef = React.useRef(value);\n  const isCheckboxInput = isBoolean(value);\n  const onFocusRef = React.useRef(onFocus);\n  const isSubmitted = isSubmittedRef.current;\n\n  const shouldValidate = () =>\n    !skipValidation({\n      hasError: !!get(errorsRef.current, name),\n      isOnBlur,\n      isOnSubmit,\n      isOnChange,\n      isReValidateOnBlur,\n      isReValidateOnSubmit,\n      isSubmitted,\n    });\n\n  const commonTask = (event: any[]) => {\n    const data = getInputValue(event[0], isCheckboxInput);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  };\n\n  const registerField = React.useCallback(() => {\n    if (fieldsRef.current[name]) {\n      fieldsRef.current[name] = {\n        ref: fieldsRef.current[name]!.ref,\n        ...rules,\n      };\n    } else {\n      register(\n        Object.defineProperty({ name, focus: onFocusRef.current }, VALUE, {\n          set(data) {\n            setInputStateValue(data);\n            valueRef.current = data;\n          },\n          get() {\n            return valueRef.current;\n          },\n        }),\n        rules,\n      );\n    }\n  }, [fieldsRef, rules, name, onFocusRef, register]);\n\n  React.useEffect(\n    () => () => {\n      !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\n    },\n    [unregister, name, fieldArrayNamesRef],\n  );\n\n  React.useEffect(() => {\n    registerField();\n  }, [registerField]);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  React.useEffect(() => {\n    if (!fieldsRef.current[name]) {\n      registerField();\n      if (isNotFieldArray) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  });\n\n  const onBlur = () => {\n    if (\n      readFormStateRef.current.touched &&\n      !get(touchedFieldsRef.current, name)\n    ) {\n      set(touchedFieldsRef.current, name, true);\n      reRender();\n    }\n\n    if (isOnBlur || (formState.isSubmitted && isReValidateOnBlur)) {\n      trigger(name);\n    }\n  };\n\n  const onChange = (...event: any[]) =>\n    setValue(name, commonTask(event), {\n      shouldValidate: shouldValidate(),\n      shouldDirty: true,\n    });\n\n  const props = {\n    ...rest,\n    onChange,\n    onBlur,\n    ...{ [isCheckboxInput ? 'checked' : VALUE]: value },\n  };\n\n  return as\n    ? React.isValidElement(as)\n      ? React.cloneElement(as, props)\n      : React.createElement(as as string, props)\n    : render\n    ? render({\n        onChange,\n        onBlur,\n        value,\n      })\n    : null;\n};\n\nexport { Controller };\n"]},"metadata":{},"sourceType":"module"}