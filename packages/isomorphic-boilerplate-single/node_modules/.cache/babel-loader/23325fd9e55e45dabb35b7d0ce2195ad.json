{"ast":null,"code":"/** Text hyphenation in Javascript.\n *  Copyright (C) 2020 Yevhen Tiurin (yevhentiurin@gmail.com)\n *  https://github.com/ytiurin/hyphen\n *\n *  Released under the ISC license\n *  https://github.com/ytiurin/hyphen/blob/master/LICENSE\n */\n(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.createHyphenator = factory();\n  }\n})(this, function () {\n  var MIN_WORD_LENGTH_BOUNDRY = 5;\n  var SETTING_DEFAULT_ASYNC = false,\n      SETTING_DEFAULT_DEBUG = false,\n      SETTING_DEFAULT_HTML = false,\n      SETTING_DEFAULT_HYPH_CHAR = \"\\u00AD\",\n      SETTING_NAME_ASYNC = \"async\",\n      SETTING_NAME_DEBUG = \"debug\",\n      SETTING_NAME_HTML = \"html\",\n      SETTING_NAME_HYPH_CHAR = \"hyphenChar\",\n      SETTING_NAME_MIN_WORD_LENGTH = \"minWordLength\";\n\n  var _global = typeof global === \"object\" ? global : typeof window === \"object\" ? window : typeof this === \"object\" ? this : {};\n\n  function cloneObj(source) {\n    var target = {};\n\n    for (var key in source) {\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function keyOrDefault(object, key, defaultValue) {\n    if (key in object) {\n      return object[key];\n    }\n\n    return defaultValue;\n  }\n\n  function exceptionsFromDefinition(patternsDefinition, hyphenChar) {\n    return patternsDefinition.exceptions.reduce(function (exceptions, exception) {\n      exceptions[exception.replace(/\\-/g, \"\")] = exception.replace(/\\-/g, hyphenChar);\n      return exceptions;\n    }, {});\n  }\n\n  function createHyphenator(patternsDefinition, options) {\n    options = options || {};\n    var //\n    asyncMode = keyOrDefault(options, SETTING_NAME_ASYNC, SETTING_DEFAULT_ASYNC),\n        caches = {},\n        debug = keyOrDefault(options, SETTING_NAME_DEBUG, SETTING_DEFAULT_DEBUG),\n        exceptions = {},\n        hyphenChar = keyOrDefault(options, SETTING_NAME_HYPH_CHAR, SETTING_DEFAULT_HYPH_CHAR),\n        patterns = patternsDefinition.patterns.map(preprocessPattern),\n        minWordLength = Math.max(options[SETTING_NAME_MIN_WORD_LENGTH] >> 0, MIN_WORD_LENGTH_BOUNDRY),\n        skipHTML = keyOrDefault(options, SETTING_NAME_HTML, SETTING_DEFAULT_HTML); // Prepare cache\n\n    var cacheKey = hyphenChar + minWordLength;\n    exceptions[cacheKey] = exceptionsFromDefinition(patternsDefinition, hyphenChar);\n    caches[cacheKey] = cloneObj(exceptions[cacheKey]);\n\n    if (asyncMode && !(\"Promise\" in _global)) {\n      throw new Error(\"Failed to create hyphenator: Could not find global Promise object, needed for hyphenator to work in async mode\");\n    }\n\n    return function (text, options) {\n      options = options || {};\n      var localDebug = keyOrDefault(options, SETTING_NAME_DEBUG, debug),\n          localHyphenChar = keyOrDefault(options, SETTING_NAME_HYPH_CHAR, hyphenChar),\n          localMinWordLength = Math.max(options[SETTING_NAME_MIN_WORD_LENGTH] >> 0, minWordLength),\n          cacheKey = localHyphenChar + localMinWordLength;\n\n      if (!exceptions[cacheKey]) {\n        exceptions[cacheKey] = exceptionsFromDefinition(patternsDefinition, localHyphenChar);\n      }\n\n      if (!caches[cacheKey]) {\n        caches[cacheKey] = cloneObj(exceptions[cacheKey]);\n      }\n\n      return start(text, patterns, caches[cacheKey], localDebug, localHyphenChar, skipHTML, localMinWordLength, asyncMode);\n    };\n  }\n\n  function createTextChunkReader(text, hyphenChar, skipHTML, minWordLength) {\n    function readNextTextChunk() {\n      var nextTextChunk = \"\";\n      shouldHyphenate = void 0;\n\n      chunkReader: while (nextCharIndex <= text.length) {\n        var //\n        nextChar = text.charAt(nextCharIndex++),\n            charIsLetter = !!nextChar && !/\\s|[\\!-\\@\\[-\\`\\{-\\~\\u2013-\\u203C]/.test(nextChar),\n            charIsAngleOpen = nextChar === \"<\",\n            charIsAngleClose = nextChar === \">\",\n            charIsHyphen = nextChar === hyphenChar;\n\n        do {\n          if (state === STATE_READ_TAG) {\n            if (charIsAngleClose) {\n              state = STATE_RETURN_UNTOUCHED;\n            }\n\n            break;\n          }\n\n          if (charIsHyphen) {\n            shouldHyphenate = SHOULD_SKIP;\n            state = STATE_READ_WORD;\n            break;\n          }\n\n          if (charIsLetter) {\n            state = STATE_READ_WORD;\n            break;\n          }\n\n          if (state === STATE_READ_WORD) {\n            state = STATE_RETURN_WORD;\n            shouldHyphenate = shouldHyphenate || nextTextChunk.length >= minWordLength && SHOULD_HYPHENATE;\n            break;\n          }\n\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_RETURN_UNTOUCHED;\n        } while (0);\n\n        if (charIsAngleOpen && state !== STATE_RETURN_WORD && skipHTML && !isSpacelike(text.charAt(nextCharIndex))) {\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_READ_TAG;\n        }\n\n        switch (state) {\n          case STATE_READ_TAG:\n            nextTextChunk += nextChar;\n            break;\n\n          case STATE_READ_WORD:\n            nextTextChunk += nextChar;\n            break;\n\n          case STATE_RETURN_UNTOUCHED:\n            nextTextChunk += nextChar;\n            break chunkReader;\n\n          case STATE_RETURN_WORD:\n            nextCharIndex--;\n            break chunkReader;\n        }\n      }\n\n      return nextTextChunk || void 0;\n    }\n\n    function shouldNextHyphenate() {\n      return shouldHyphenate === SHOULD_HYPHENATE;\n    }\n\n    var isSpacelike = RegExp.prototype.test.bind(/\\s/);\n    var //\n    nextCharIndex = 0,\n        SHOULD_HYPHENATE = 1,\n        SHOULD_SKIP = 2,\n        shouldHyphenate,\n        STATE_READ_TAG = 1,\n        STATE_READ_WORD = 2,\n        STATE_RETURN_UNTOUCHED = 3,\n        STATE_RETURN_WORD = 4,\n        state;\n    return [readNextTextChunk, shouldNextHyphenate];\n  }\n\n  function hyphenateWord(text, patterns, debug, hyphenChar) {\n    var //\n    levels = new Array(text.length + 1),\n        loweredText = text.toLocaleLowerCase(),\n        p = [],\n        patternData,\n        patternIndex = 0;\n\n    for (var i = levels.length; i--;) levels[i] = 0;\n\n    while (patternData = patterns[patternIndex++]) {\n      var //\n      fromChar = 0,\n          endPattern = false;\n\n      while (!endPattern) {\n        var //\n        patternEntityIndex = loweredText.indexOf(patternData.text, fromChar),\n            patternFits = patternEntityIndex > -1 && (patternData.stickToLeft ? patternEntityIndex === 0 : true) && (patternData.stickToRight ? patternEntityIndex + patternData.text.length === text.length : true);\n\n        if (patternFits) {\n          p.push(patternData.pattern + \">\" + patternData.levels.join(\"\"));\n\n          for (var i = 0; i < patternData.levels.length; i++) levels[patternEntityIndex + i] = Math.max(patternData.levels[i], levels[patternEntityIndex + i]);\n        }\n\n        if (patternEntityIndex > -1 && patternData.text.length > 0) {\n          fromChar = patternEntityIndex + patternData.text.length + 1;\n        } else {\n          endPattern = true;\n        }\n      }\n    }\n\n    levels[0] = levels[1] = levels[levels.length - 1] = levels[levels.length - 2] = 0;\n    var //\n    hyphenatedText = \"\",\n        leveledText = \"\",\n        debugHyphenatedText = \"\";\n\n    for (var i = 0; i < levels.length; i++) {\n      hyphenatedText += (levels[i] % 2 === 1 ? hyphenChar : \"\") + text.charAt(i);\n      debugHyphenatedText += (levels[i] % 2 === 1 ? \"-\" : \"\") + text.charAt(i);\n      leveledText += (levels[i] > 0 ? levels[i] : \"\") + text.charAt(i);\n    }\n\n    if (debug) console.log.apply(console, [text, \"->\"].concat(p).concat([\"->\"]).concat(levels).concat([\"->\", leveledText]).concat([\"->\", debugHyphenatedText]));\n    return hyphenatedText;\n  }\n\n  function preprocessPattern(pattern) {\n    var //\n    patternCharIndex = 0,\n        patternChar,\n        patternData = {\n      pattern: pattern,\n      text: \"\",\n      levels: [],\n      stickToLeft: 0,\n      stickToRight: 0\n    },\n        states = {\n      alphabet: 1,\n      level: 2,\n      stickToLeft: 3,\n      stickToRight: 4\n    };\n\n    while (patternChar = pattern.charAt(patternCharIndex++)) {\n      var //\n      charIsDot = patternChar === \".\",\n          charIsNumber = !charIsDot && /\\d/.test(patternChar),\n          state = charIsDot ? patternCharIndex - 1 === 0 ? states.stickToLeft : states.stickToRight : charIsNumber ? states.level : states.alphabet;\n\n      switch (state) {\n        case states.alphabet:\n          !prevCharIsNumber && patternData.levels.push(0);\n          patternData.text += patternChar;\n          break;\n\n        case states.level:\n          patternData.levels.push(parseInt(patternChar));\n          break;\n\n        case states.stickToLeft:\n          patternData.stickToLeft = true;\n          break;\n\n        case states.stickToRight:\n          patternData.stickToRight = true;\n          break;\n      }\n\n      var prevCharIsNumber = charIsNumber;\n    }\n\n    return patternData;\n  }\n\n  function start(text, patterns, cache, debug, hyphenChar, skipHTML, minWordLength, isAsync) {\n    function done() {\n      allTime = new Date() - allTime;\n      resolveNewText(newText);\n\n      if (debug) {\n        console.log(\"----------------\\nHyphenation stats: \" + processedN + \" text chunks processed, \" + hyphenatedN + \" words hyphenated\");\n        console.log(\"Work time: \" + workTime / 1000);\n        console.log(\"Wait time: \" + (allTime - workTime) / 1000);\n        console.log(\"All time: \" + allTime / 1000);\n      }\n    }\n\n    var //\n    newText = \"\",\n        nextTextChunk,\n        reader = createTextChunkReader(text, hyphenChar, skipHTML, minWordLength),\n        readNextTextChunk = reader[0],\n        shouldNextHyphenate = reader[1],\n        states = {\n      hyphenateWord: 1,\n      concatenate: 2\n    },\n        processedN = 0,\n        hyphenatedN = 0;\n    var //\n    allTime = new Date(),\n        workTime = 0;\n\n    var resolveNewText = function resolveNewText() {};\n\n    function nextTick() {\n      var loopStart = new Date();\n\n      while ((!isAsync || new Date() - loopStart < 10) && (nextTextChunk = readNextTextChunk())) {\n        var state = shouldNextHyphenate() ? states.hyphenateWord : states.concatenate;\n\n        switch (state) {\n          case states.hyphenateWord:\n            if (!cache[nextTextChunk]) cache[nextTextChunk] = hyphenateWord(nextTextChunk, patterns, debug, hyphenChar);\n            if (nextTextChunk !== cache[nextTextChunk]) hyphenatedN++;\n            nextTextChunk = cache[nextTextChunk];\n\n          case states.concatenate:\n            newText += nextTextChunk;\n        }\n\n        processedN++;\n      }\n\n      workTime += new Date() - loopStart;\n\n      if (!nextTextChunk) {\n        done();\n      } else {\n        setTimeout(nextTick);\n      }\n    }\n\n    if (isAsync) {\n      setTimeout(nextTick);\n      return new Promise(function (resolve) {\n        resolveNewText = resolve;\n      });\n    } else {\n      nextTick();\n      return newText;\n    }\n  }\n\n  return createHyphenator;\n});","map":{"version":3,"sources":["/Users/pezannekhambatta/Desktop/resumio/node_modules/hyphen/hyphen.js"],"names":["root","factory","define","amd","module","exports","createHyphenator","MIN_WORD_LENGTH_BOUNDRY","SETTING_DEFAULT_ASYNC","SETTING_DEFAULT_DEBUG","SETTING_DEFAULT_HTML","SETTING_DEFAULT_HYPH_CHAR","SETTING_NAME_ASYNC","SETTING_NAME_DEBUG","SETTING_NAME_HTML","SETTING_NAME_HYPH_CHAR","SETTING_NAME_MIN_WORD_LENGTH","_global","global","window","cloneObj","source","target","key","keyOrDefault","object","defaultValue","exceptionsFromDefinition","patternsDefinition","hyphenChar","exceptions","reduce","exception","replace","options","asyncMode","caches","debug","patterns","map","preprocessPattern","minWordLength","Math","max","skipHTML","cacheKey","Error","text","localDebug","localHyphenChar","localMinWordLength","start","createTextChunkReader","readNextTextChunk","nextTextChunk","shouldHyphenate","chunkReader","nextCharIndex","length","nextChar","charAt","charIsLetter","test","charIsAngleOpen","charIsAngleClose","charIsHyphen","state","STATE_READ_TAG","STATE_RETURN_UNTOUCHED","SHOULD_SKIP","STATE_READ_WORD","STATE_RETURN_WORD","SHOULD_HYPHENATE","isSpacelike","shouldNextHyphenate","RegExp","prototype","bind","hyphenateWord","levels","Array","loweredText","toLocaleLowerCase","p","patternData","patternIndex","i","fromChar","endPattern","patternEntityIndex","indexOf","patternFits","stickToLeft","stickToRight","push","pattern","join","hyphenatedText","leveledText","debugHyphenatedText","console","log","apply","concat","patternCharIndex","patternChar","states","alphabet","level","charIsDot","charIsNumber","prevCharIsNumber","parseInt","cache","isAsync","done","allTime","Date","resolveNewText","newText","processedN","hyphenatedN","workTime","reader","concatenate","nextTick","loopStart","setTimeout","Promise","resolve"],"mappings":"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","sourcesContent":["/** Text hyphenation in Javascript.\n *  Copyright (C) 2020 Yevhen Tiurin (yevhentiurin@gmail.com)\n *  https://github.com/ytiurin/hyphen\n *\n *  Released under the ISC license\n *  https://github.com/ytiurin/hyphen/blob/master/LICENSE\n */\n(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.createHyphenator = factory();\n  }\n})(this, function () {\n  var MIN_WORD_LENGTH_BOUNDRY = 5;\n\n  var SETTING_DEFAULT_ASYNC = false,\n    SETTING_DEFAULT_DEBUG = false,\n    SETTING_DEFAULT_HTML = false,\n    SETTING_DEFAULT_HYPH_CHAR = \"\\u00AD\",\n    SETTING_NAME_ASYNC = \"async\",\n    SETTING_NAME_DEBUG = \"debug\",\n    SETTING_NAME_HTML = \"html\",\n    SETTING_NAME_HYPH_CHAR = \"hyphenChar\",\n    SETTING_NAME_MIN_WORD_LENGTH = \"minWordLength\";\n\n  var _global =\n    typeof global === \"object\"\n      ? global\n      : typeof window === \"object\"\n      ? window\n      : typeof this === \"object\"\n      ? this\n      : {};\n\n  function cloneObj(source) {\n    var target = {};\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n\n  function keyOrDefault(object, key, defaultValue) {\n    if (key in object) {\n      return object[key];\n    }\n    return defaultValue;\n  }\n\n  function exceptionsFromDefinition(patternsDefinition, hyphenChar) {\n    return patternsDefinition.exceptions.reduce(function (\n      exceptions,\n      exception\n    ) {\n      exceptions[exception.replace(/\\-/g, \"\")] = exception.replace(\n        /\\-/g,\n        hyphenChar\n      );\n      return exceptions;\n    },\n    {});\n  }\n\n  function createHyphenator(patternsDefinition, options) {\n    options = options || {};\n    var //\n      asyncMode = keyOrDefault(\n        options,\n        SETTING_NAME_ASYNC,\n        SETTING_DEFAULT_ASYNC\n      ),\n      caches = {},\n      debug = keyOrDefault(options, SETTING_NAME_DEBUG, SETTING_DEFAULT_DEBUG),\n      exceptions = {},\n      hyphenChar = keyOrDefault(\n        options,\n        SETTING_NAME_HYPH_CHAR,\n        SETTING_DEFAULT_HYPH_CHAR\n      ),\n      patterns = patternsDefinition.patterns.map(preprocessPattern),\n      minWordLength = Math.max(\n        options[SETTING_NAME_MIN_WORD_LENGTH] >> 0,\n        MIN_WORD_LENGTH_BOUNDRY\n      ),\n      skipHTML = keyOrDefault(options, SETTING_NAME_HTML, SETTING_DEFAULT_HTML);\n\n    // Prepare cache\n    var cacheKey = hyphenChar + minWordLength;\n    exceptions[cacheKey] = exceptionsFromDefinition(\n      patternsDefinition,\n      hyphenChar\n    );\n    caches[cacheKey] = cloneObj(exceptions[cacheKey]);\n\n    if (asyncMode && !(\"Promise\" in _global)) {\n      throw new Error(\n        \"Failed to create hyphenator: Could not find global Promise object, needed for hyphenator to work in async mode\"\n      );\n    }\n\n    return function (text, options) {\n      options = options || {};\n\n      var localDebug = keyOrDefault(options, SETTING_NAME_DEBUG, debug),\n        localHyphenChar = keyOrDefault(\n          options,\n          SETTING_NAME_HYPH_CHAR,\n          hyphenChar\n        ),\n        localMinWordLength = Math.max(\n          options[SETTING_NAME_MIN_WORD_LENGTH] >> 0,\n          minWordLength\n        ),\n        cacheKey = localHyphenChar + localMinWordLength;\n\n      if (!exceptions[cacheKey]) {\n        exceptions[cacheKey] = exceptionsFromDefinition(\n          patternsDefinition,\n          localHyphenChar\n        );\n      }\n\n      if (!caches[cacheKey]) {\n        caches[cacheKey] = cloneObj(exceptions[cacheKey]);\n      }\n\n      return start(\n        text,\n        patterns,\n        caches[cacheKey],\n        localDebug,\n        localHyphenChar,\n        skipHTML,\n        localMinWordLength,\n        asyncMode\n      );\n    };\n  }\n  function createTextChunkReader(text, hyphenChar, skipHTML, minWordLength) {\n    function readNextTextChunk() {\n      var nextTextChunk = \"\";\n\n      shouldHyphenate = void 0;\n\n      chunkReader: while (nextCharIndex <= text.length) {\n        var //\n          nextChar = text.charAt(nextCharIndex++),\n          charIsLetter =\n            !!nextChar && !/\\s|[\\!-\\@\\[-\\`\\{-\\~\\u2013-\\u203C]/.test(nextChar),\n          charIsAngleOpen = nextChar === \"<\",\n          charIsAngleClose = nextChar === \">\",\n          charIsHyphen = nextChar === hyphenChar;\n\n        do {\n          if (state === STATE_READ_TAG) {\n            if (charIsAngleClose) {\n              state = STATE_RETURN_UNTOUCHED;\n            }\n            break;\n          }\n\n          if (charIsHyphen) {\n            shouldHyphenate = SHOULD_SKIP;\n            state = STATE_READ_WORD;\n            break;\n          }\n\n          if (charIsLetter) {\n            state = STATE_READ_WORD;\n            break;\n          }\n\n          if (state === STATE_READ_WORD) {\n            state = STATE_RETURN_WORD;\n            shouldHyphenate =\n              shouldHyphenate ||\n              (nextTextChunk.length >= minWordLength && SHOULD_HYPHENATE);\n            break;\n          }\n\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_RETURN_UNTOUCHED;\n        } while (0);\n\n        if (\n          charIsAngleOpen &&\n          state !== STATE_RETURN_WORD &&\n          skipHTML &&\n          !isSpacelike(text.charAt(nextCharIndex))\n        ) {\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_READ_TAG;\n        }\n\n        switch (state) {\n          case STATE_READ_TAG:\n            nextTextChunk += nextChar;\n            break;\n\n          case STATE_READ_WORD:\n            nextTextChunk += nextChar;\n            break;\n\n          case STATE_RETURN_UNTOUCHED:\n            nextTextChunk += nextChar;\n            break chunkReader;\n\n          case STATE_RETURN_WORD:\n            nextCharIndex--;\n            break chunkReader;\n        }\n      }\n      return nextTextChunk || void 0;\n    }\n\n    function shouldNextHyphenate() {\n      return shouldHyphenate === SHOULD_HYPHENATE;\n    }\n\n    var isSpacelike = RegExp.prototype.test.bind(/\\s/);\n\n    var //\n      nextCharIndex = 0,\n      SHOULD_HYPHENATE = 1,\n      SHOULD_SKIP = 2,\n      shouldHyphenate,\n      STATE_READ_TAG = 1,\n      STATE_READ_WORD = 2,\n      STATE_RETURN_UNTOUCHED = 3,\n      STATE_RETURN_WORD = 4,\n      state;\n\n    return [readNextTextChunk, shouldNextHyphenate];\n  }\n  function hyphenateWord(text, patterns, debug, hyphenChar) {\n    var //\n      levels = new Array(text.length + 1),\n      loweredText = text.toLocaleLowerCase(),\n      p = [],\n      patternData,\n      patternIndex = 0;\n\n    for (var i = levels.length; i--; ) levels[i] = 0;\n\n    while ((patternData = patterns[patternIndex++])) {\n      var //\n        fromChar = 0,\n        endPattern = false;\n      while (!endPattern) {\n        var //\n          patternEntityIndex = loweredText.indexOf(patternData.text, fromChar),\n          patternFits =\n            patternEntityIndex > -1 &&\n            (patternData.stickToLeft ? patternEntityIndex === 0 : true) &&\n            (patternData.stickToRight\n              ? patternEntityIndex + patternData.text.length === text.length\n              : true);\n\n        if (patternFits) {\n          p.push(patternData.pattern + \">\" + patternData.levels.join(\"\"));\n\n          for (var i = 0; i < patternData.levels.length; i++)\n            levels[patternEntityIndex + i] = Math.max(\n              patternData.levels[i],\n              levels[patternEntityIndex + i]\n            );\n        }\n        if (patternEntityIndex > -1 && patternData.text.length > 0) {\n          fromChar = patternEntityIndex + patternData.text.length + 1;\n        } else {\n          endPattern = true;\n        }\n      }\n    }\n\n    levels[0] = levels[1] = levels[levels.length - 1] = levels[\n      levels.length - 2\n    ] = 0;\n\n    var //\n      hyphenatedText = \"\",\n      leveledText = \"\",\n      debugHyphenatedText = \"\";\n\n    for (var i = 0; i < levels.length; i++) {\n      hyphenatedText +=\n        (levels[i] % 2 === 1 ? hyphenChar : \"\") + text.charAt(i);\n      debugHyphenatedText += (levels[i] % 2 === 1 ? \"-\" : \"\") + text.charAt(i);\n      leveledText += (levels[i] > 0 ? levels[i] : \"\") + text.charAt(i);\n    }\n\n    if (debug)\n      console.log.apply(\n        console,\n        [text, \"->\"]\n          .concat(p)\n          .concat([\"->\"])\n          .concat(levels)\n          .concat([\"->\", leveledText])\n          .concat([\"->\", debugHyphenatedText])\n      );\n\n    return hyphenatedText;\n  }\n  function preprocessPattern(pattern) {\n    var //\n      patternCharIndex = 0,\n      patternChar,\n      patternData = {\n        pattern: pattern,\n        text: \"\",\n        levels: [],\n        stickToLeft: 0,\n        stickToRight: 0\n      },\n      states = { alphabet: 1, level: 2, stickToLeft: 3, stickToRight: 4 };\n\n    while ((patternChar = pattern.charAt(patternCharIndex++))) {\n      var //\n        charIsDot = patternChar === \".\",\n        charIsNumber = !charIsDot && /\\d/.test(patternChar),\n        state = charIsDot\n          ? patternCharIndex - 1 === 0\n            ? states.stickToLeft\n            : states.stickToRight\n          : charIsNumber\n          ? states.level\n          : states.alphabet;\n\n      switch (state) {\n        case states.alphabet:\n          !prevCharIsNumber && patternData.levels.push(0);\n          patternData.text += patternChar;\n          break;\n\n        case states.level:\n          patternData.levels.push(parseInt(patternChar));\n          break;\n\n        case states.stickToLeft:\n          patternData.stickToLeft = true;\n          break;\n\n        case states.stickToRight:\n          patternData.stickToRight = true;\n          break;\n      }\n\n      var prevCharIsNumber = charIsNumber;\n    }\n\n    return patternData;\n  }\n  function start(\n    text,\n    patterns,\n    cache,\n    debug,\n    hyphenChar,\n    skipHTML,\n    minWordLength,\n    isAsync\n  ) {\n    function done() {\n      allTime = new Date() - allTime;\n      resolveNewText(newText);\n\n      if (debug) {\n        console.log(\n          \"----------------\\nHyphenation stats: \" +\n            processedN +\n            \" text chunks processed, \" +\n            hyphenatedN +\n            \" words hyphenated\"\n        );\n        console.log(\"Work time: \" + workTime / 1000);\n        console.log(\"Wait time: \" + (allTime - workTime) / 1000);\n        console.log(\"All time: \" + allTime / 1000);\n      }\n    }\n\n    var //\n      newText = \"\",\n      nextTextChunk,\n      reader = createTextChunkReader(text, hyphenChar, skipHTML, minWordLength),\n      readNextTextChunk = reader[0],\n      shouldNextHyphenate = reader[1],\n      states = { hyphenateWord: 1, concatenate: 2 },\n      processedN = 0,\n      hyphenatedN = 0;\n\n    var //\n      allTime = new Date(),\n      workTime = 0;\n\n    var resolveNewText = function () {};\n\n    function nextTick() {\n      var loopStart = new Date();\n\n      while (\n        (!isAsync || new Date() - loopStart < 10) &&\n        (nextTextChunk = readNextTextChunk())\n      ) {\n        var state = shouldNextHyphenate()\n          ? states.hyphenateWord\n          : states.concatenate;\n\n        switch (state) {\n          case states.hyphenateWord:\n            if (!cache[nextTextChunk])\n              cache[nextTextChunk] = hyphenateWord(\n                nextTextChunk,\n                patterns,\n                debug,\n                hyphenChar\n              );\n\n            if (nextTextChunk !== cache[nextTextChunk]) hyphenatedN++;\n\n            nextTextChunk = cache[nextTextChunk];\n\n          case states.concatenate:\n            newText += nextTextChunk;\n        }\n\n        processedN++;\n      }\n      workTime += new Date() - loopStart;\n\n      if (!nextTextChunk) {\n        done();\n      } else {\n        setTimeout(nextTick);\n      }\n    }\n\n    if (isAsync) {\n      setTimeout(nextTick);\n      return new Promise(function (resolve) {\n        resolveNewText = resolve;\n      });\n    } else {\n      nextTick();\n      return newText;\n    }\n  }\n\n  return createHyphenator;\n});\n"]},"metadata":{},"sourceType":"script"}