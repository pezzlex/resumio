{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/pezannekhambatta/Desktop/resumio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/pezannekhambatta/Desktop/resumio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/pezannekhambatta/Desktop/resumio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar INITIAL_STATE = 1;\nvar FAIL_STATE = 0;\n/**\n * A StateMachine represents a deterministic finite automaton.\n * It can perform matches over a sequence of values, similar to a regular expression.\n */\n\nclass StateMachine {\n  constructor(dfa) {\n    this.stateTable = dfa.stateTable;\n    this.accepting = dfa.accepting;\n    this.tags = dfa.tags;\n  }\n  /**\n   * Returns an iterable object that yields pattern matches over the input sequence.\n   * Matches are of the form [startIndex, endIndex, tags].\n   */\n\n\n  match(str) {\n    var self = this;\n    return {\n      [Symbol.iterator]() {\n        return /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var state, startRun, lastAccepting, lastState, p, c;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                state = INITIAL_STATE;\n                startRun = null;\n                lastAccepting = null;\n                lastState = null;\n                p = 0;\n\n              case 5:\n                if (!(p < str.length)) {\n                  _context.next = 21;\n                  break;\n                }\n\n                c = str[p];\n                lastState = state;\n                state = self.stateTable[state][c];\n\n                if (!(state === FAIL_STATE)) {\n                  _context.next = 15;\n                  break;\n                }\n\n                if (!(startRun != null && lastAccepting != null && lastAccepting >= startRun)) {\n                  _context.next = 13;\n                  break;\n                }\n\n                _context.next = 13;\n                return [startRun, lastAccepting, self.tags[lastState]];\n\n              case 13:\n                // reset the state as if we started over from the initial state\n                state = self.stateTable[INITIAL_STATE][c];\n                startRun = null;\n\n              case 15:\n                // start a run if not in the failure state\n                if (state !== FAIL_STATE && startRun == null) {\n                  startRun = p;\n                } // if accepting, mark the potential match end\n\n\n                if (self.accepting[state]) {\n                  lastAccepting = p;\n                } // reset the state to the initial state if we get into the failure state\n\n\n                if (state === FAIL_STATE) {\n                  state = INITIAL_STATE;\n                }\n\n              case 18:\n                p++;\n                _context.next = 5;\n                break;\n\n              case 21:\n                if (!(startRun != null && lastAccepting != null && lastAccepting >= startRun)) {\n                  _context.next = 24;\n                  break;\n                }\n\n                _context.next = 24;\n                return [startRun, lastAccepting, self.tags[state]];\n\n              case 24:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee);\n        })();\n      }\n\n    };\n  }\n  /**\n   * For each match over the input sequence, action functions matching\n   * the tag definitions in the input pattern are called with the startIndex,\n   * endIndex, and sub-match sequence.\n   */\n\n\n  apply(str, actions) {\n    var _iterator = _createForOfIteratorHelper(this.match(str)),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 3),\n            start = _step$value[0],\n            end = _step$value[1],\n            tags = _step$value[2];\n\n        var _iterator2 = _createForOfIteratorHelper(tags),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var tag = _step2.value;\n\n            if (typeof actions[tag] === 'function') {\n              actions[tag](start, end, str.slice(start, end + 1));\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n}\n\nmodule.exports = StateMachine;","map":{"version":3,"sources":["src/StateMachine.js"],"names":["INITIAL_STATE","FAIL_STATE","constructor","dfa","match","self","Symbol","state","startRun","lastAccepting","lastState","p","str","c","apply","actions","end"],"mappings":"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","sourcesContent":["const INITIAL_STATE = 1;\nconst FAIL_STATE = 0;\n\n/**\n * A StateMachine represents a deterministic finite automaton.\n * It can perform matches over a sequence of values, similar to a regular expression.\n */\nexport default class StateMachine {\n  constructor(dfa) {\n    this.stateTable = dfa.stateTable;\n    this.accepting = dfa.accepting;\n    this.tags = dfa.tags;\n  }\n\n  /**\n   * Returns an iterable object that yields pattern matches over the input sequence.\n   * Matches are of the form [startIndex, endIndex, tags].\n   */\n  match(str) {\n    let self = this;\n    return {\n      *[Symbol.iterator]() {\n        let state = INITIAL_STATE;\n        let startRun = null;\n        let lastAccepting = null;\n        let lastState = null;\n\n        for (let p = 0; p < str.length; p++) {\n          let c = str[p];\n\n          lastState = state;\n          state = self.stateTable[state][c];\n\n          if (state === FAIL_STATE) {\n            // yield the last match if any\n            if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {\n              yield [startRun, lastAccepting, self.tags[lastState]];\n            }\n\n            // reset the state as if we started over from the initial state\n            state = self.stateTable[INITIAL_STATE][c];\n            startRun = null;\n          }\n\n          // start a run if not in the failure state\n          if (state !== FAIL_STATE && startRun == null) {\n            startRun = p;\n          }\n\n          // if accepting, mark the potential match end\n          if (self.accepting[state]) {\n            lastAccepting = p;\n          }\n\n          // reset the state to the initial state if we get into the failure state\n          if (state === FAIL_STATE) {\n            state = INITIAL_STATE;\n          }\n        }\n\n        // yield the last match if any\n        if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {\n          yield [startRun, lastAccepting, self.tags[state]];\n        }\n      }\n    };\n  }\n\n  /**\n   * For each match over the input sequence, action functions matching\n   * the tag definitions in the input pattern are called with the startIndex,\n   * endIndex, and sub-match sequence.\n   */\n  apply(str, actions) {\n    for (let [start, end, tags] of this.match(str)) {\n      for (let tag of tags) {\n        if (typeof actions[tag] === 'function') {\n          actions[tag](start, end, str.slice(start, end + 1));\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}