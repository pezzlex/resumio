{"ast":null,"code":"/*\nHTML escaping is the same as React's\n(on purpose.) Therefore, it has the following Copyright and Licensing:\n\nCopyright 2013-2014, Facebook, Inc.\nAll rights reserved.\n\nThis source code is licensed under the BSD-style license found in the LICENSE\nfile in the root directory of React's source tree.\n*/\nimport * as React from 'react';\nimport IntlMessageFormat from 'intl-messageformat';\nimport memoizeIntlConstructor from 'intl-format-cache';\nimport { invariant } from '@formatjs/intl-utils';\nimport { UnsupportedFormatterError } from './error';\nexport function filterProps(props, whitelist, defaults) {\n  if (defaults === void 0) {\n    defaults = {};\n  }\n\n  return whitelist.reduce(function (filtered, name) {\n    if (name in props) {\n      filtered[name] = props[name];\n    } else if (name in defaults) {\n      filtered[name] = defaults[name];\n    }\n\n    return filtered;\n  }, {});\n}\nexport function invariantIntlContext(intl) {\n  invariant(intl, '[React Intl] Could not find required `intl` object. ' + '<IntlProvider> needs to exist in the component ancestry.');\n}\nexport var defaultErrorHandler = function defaultErrorHandler(error) {\n  if (process.env.NODE_ENV !== 'production') {\n    console.error(error);\n  }\n};\nexport var DEFAULT_INTL_CONFIG = {\n  formats: {},\n  messages: {},\n  timeZone: undefined,\n  textComponent: React.Fragment,\n  defaultLocale: 'en',\n  defaultFormats: {},\n  onError: defaultErrorHandler\n};\nexport function createIntlCache() {\n  return {\n    dateTime: {},\n    number: {},\n    message: {},\n    relativeTime: {},\n    pluralRules: {},\n    list: {},\n    displayNames: {}\n  };\n}\n/**\n * Create intl formatters and populate cache\n * @param cache explicit cache to prevent leaking memory\n */\n\nexport function createFormatters(cache) {\n  if (cache === void 0) {\n    cache = createIntlCache();\n  }\n\n  var RelativeTimeFormat = Intl.RelativeTimeFormat;\n  var ListFormat = Intl.ListFormat;\n  var DisplayNames = Intl.DisplayNames;\n  return {\n    getDateTimeFormat: memoizeIntlConstructor(Intl.DateTimeFormat, cache.dateTime),\n    getNumberFormat: memoizeIntlConstructor(Intl.NumberFormat, cache.number),\n    getMessageFormat: memoizeIntlConstructor(IntlMessageFormat, cache.message),\n    getRelativeTimeFormat: memoizeIntlConstructor(RelativeTimeFormat, cache.relativeTime),\n    getPluralRules: memoizeIntlConstructor(Intl.PluralRules, cache.pluralRules),\n    getListFormat: memoizeIntlConstructor(ListFormat, cache.list),\n    getDisplayNames: memoizeIntlConstructor(DisplayNames, cache.displayNames)\n  };\n}\nexport function getNamedFormat(formats, type, name, onError) {\n  var formatType = formats && formats[type];\n  var format;\n\n  if (formatType) {\n    format = formatType[name];\n  }\n\n  if (format) {\n    return format;\n  }\n\n  onError(new UnsupportedFormatterError(\"No \" + type + \" format named: \" + name));\n}","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\nHTML escaping is the same as React's\n(on purpose.) Therefore, it has the following Copyright and Licensing:\n\nCopyright 2013-2014, Facebook, Inc.\nAll rights reserved.\n\nThis source code is licensed under the BSD-style license found in the LICENSE\nfile in the root directory of React's source tree.\n*/\nimport * as React from 'react';\nimport IntlMessageFormat from 'intl-messageformat';\nimport memoizeIntlConstructor from 'intl-format-cache';\nimport { invariant } from '@formatjs/intl-utils';\nimport { UnsupportedFormatterError } from './error';\nexport function filterProps(props, whitelist, defaults) {\n    if (defaults === void 0) { defaults = {}; }\n    return whitelist.reduce(function (filtered, name) {\n        if (name in props) {\n            filtered[name] = props[name];\n        }\n        else if (name in defaults) {\n            filtered[name] = defaults[name];\n        }\n        return filtered;\n    }, {});\n}\nexport function invariantIntlContext(intl) {\n    invariant(intl, '[React Intl] Could not find required `intl` object. ' +\n        '<IntlProvider> needs to exist in the component ancestry.');\n}\nexport var defaultErrorHandler = function (error) {\n    if (process.env.NODE_ENV !== 'production') {\n        console.error(error);\n    }\n};\nexport var DEFAULT_INTL_CONFIG = {\n    formats: {},\n    messages: {},\n    timeZone: undefined,\n    textComponent: React.Fragment,\n    defaultLocale: 'en',\n    defaultFormats: {},\n    onError: defaultErrorHandler,\n};\nexport function createIntlCache() {\n    return {\n        dateTime: {},\n        number: {},\n        message: {},\n        relativeTime: {},\n        pluralRules: {},\n        list: {},\n        displayNames: {},\n    };\n}\n/**\n * Create intl formatters and populate cache\n * @param cache explicit cache to prevent leaking memory\n */\nexport function createFormatters(cache) {\n    if (cache === void 0) { cache = createIntlCache(); }\n    var RelativeTimeFormat = Intl.RelativeTimeFormat;\n    var ListFormat = Intl.ListFormat;\n    var DisplayNames = Intl.DisplayNames;\n    return {\n        getDateTimeFormat: memoizeIntlConstructor(Intl.DateTimeFormat, cache.dateTime),\n        getNumberFormat: memoizeIntlConstructor(Intl.NumberFormat, cache.number),\n        getMessageFormat: memoizeIntlConstructor(IntlMessageFormat, cache.message),\n        getRelativeTimeFormat: memoizeIntlConstructor(RelativeTimeFormat, cache.relativeTime),\n        getPluralRules: memoizeIntlConstructor(Intl.PluralRules, cache.pluralRules),\n        getListFormat: memoizeIntlConstructor(ListFormat, cache.list),\n        getDisplayNames: memoizeIntlConstructor(DisplayNames, cache.displayNames),\n    };\n}\nexport function getNamedFormat(formats, type, name, onError) {\n    var formatType = formats && formats[type];\n    var format;\n    if (formatType) {\n        format = formatType[name];\n    }\n    if (format) {\n        return format;\n    }\n    onError(new UnsupportedFormatterError(\"No \" + type + \" format named: \" + name));\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}