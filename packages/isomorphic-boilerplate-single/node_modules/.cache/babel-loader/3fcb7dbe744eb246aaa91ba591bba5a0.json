{"ast":null,"code":"import zlib from 'zlib';\n\nvar range = function range(left, right, inclusive) {\n  var range = [];\n  var ascending = left < right;\n  var end = !inclusive ? right : ascending ? right + 1 : right - 1;\n\n  for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n    range.push(i);\n  }\n\n  return range;\n};\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar toConsumableArray = function toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar PNG = function () {\n  createClass(PNG, null, [{\n    key: 'decode',\n    value: function decode(path, fn) {\n      {\n        throw new Error('PNG.decode not available in browser build');\n      }\n    }\n  }, {\n    key: 'load',\n    value: function load(path) {\n      {\n        throw new Error('PNG.load not available in browser build');\n      }\n    }\n  }]);\n\n  function PNG(data) {\n    var _this = this;\n\n    classCallCheck(this, PNG);\n    var i = void 0;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n\n    while (true) {\n      var end;\n      var chunkSize = this.readUInt32();\n\n      var section = function () {\n        var result = [];\n\n        for (i = 0; i < 4; i++) {\n          result.push(String.fromCharCode(_this.data[_this.pos++]));\n        }\n\n        return result;\n      }().join('');\n\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n\n        case 'IDAT':\n          for (i = 0, end = chunkSize; i < end; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n\n          break;\n\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n\n              if (short > 0) {\n                var asc, end1;\n\n                for (i = 0, end1 = short, asc = 0 <= end1; asc ? i < end1 : i > end1; asc ? i++ : i--) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n\n              break;\n\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n\n          break;\n\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, toConsumableArray(Array.from(text.slice(0, index) || [])));\n          this.text[key] = String.fromCharCode.apply(String, toConsumableArray(Array.from(text.slice(index + 1) || [])));\n          break;\n\n        case 'IEND':\n          // we've got everything we need!\n          this.colors = function () {\n            switch (_this.colorType) {\n              case 0:\n              case 3:\n              case 4:\n                return 1;\n\n              case 2:\n              case 6:\n                return 3;\n            }\n          }();\n\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n\n          this.colorSpace = function () {\n            switch (_this.colors) {\n              case 1:\n                return 'DeviceGray';\n\n              case 3:\n                return 'DeviceRGB';\n            }\n          }();\n\n          this.imgData = new Buffer(this.imgData);\n          return;\n          break;\n\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error(\"Incomplete or corrupt PNG file\");\n      }\n    }\n  }\n\n  createClass(PNG, [{\n    key: 'read',\n    value: function read(bytes) {\n      var _this2 = this;\n\n      return range(0, bytes, false).map(function (i) {\n        return _this2.data[_this2.pos++];\n      });\n    }\n  }, {\n    key: 'readUInt32',\n    value: function readUInt32() {\n      var b1 = this.data[this.pos++] << 24;\n      var b2 = this.data[this.pos++] << 16;\n      var b3 = this.data[this.pos++] << 8;\n      var b4 = this.data[this.pos++];\n      return b1 | b2 | b3 | b4;\n    }\n  }, {\n    key: 'readUInt16',\n    value: function readUInt16() {\n      var b1 = this.data[this.pos++] << 8;\n      var b2 = this.data[this.pos++];\n      return b1 | b2;\n    }\n  }, {\n    key: 'decodePixels',\n    value: function decodePixels(fn) {\n      var _this3 = this;\n\n      return zlib.inflate(this.imgData, function (err, data) {\n        if (err) {\n          throw err;\n        }\n\n        var pixelBytes = _this3.pixelBitlength / 8;\n        var scanlineLength = pixelBytes * _this3.width;\n        var pixels = new Buffer(scanlineLength * _this3.height);\n        var length = data.length;\n        var row = 0;\n        var pos = 0;\n        var c = 0;\n\n        while (pos < length) {\n          var byte, col, i, left, upper;\n          var end;\n          var end1;\n          var end2;\n          var end3;\n          var end4;\n\n          switch (data[pos++]) {\n            case 0:\n              // None\n              for (i = 0, end = scanlineLength; i < end; i++) {\n                pixels[c++] = data[pos++];\n              }\n\n              break;\n\n            case 1:\n              // Sub\n              for (i = 0, end1 = scanlineLength; i < end1; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n                pixels[c++] = (byte + left) % 256;\n              }\n\n              break;\n\n            case 2:\n              // Up\n              for (i = 0, end2 = scanlineLength; i < end2; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                pixels[c++] = (upper + byte) % 256;\n              }\n\n              break;\n\n            case 3:\n              // Average\n              for (i = 0, end3 = scanlineLength; i < end3; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n                upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                pixels[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n\n              break;\n\n            case 4:\n              // Paeth\n              for (i = 0, end4 = scanlineLength; i < end4; i++) {\n                var paeth, upperLeft;\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                  upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];\n                }\n\n                var p = left + upper - upperLeft;\n                var pa = Math.abs(p - left);\n                var pb = Math.abs(p - upper);\n                var pc = Math.abs(p - upperLeft);\n\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n\n                pixels[c++] = (byte + paeth) % 256;\n              }\n\n              break;\n\n            default:\n              throw new Error('Invalid filter algorithm: ' + data[pos - 1]);\n          }\n\n          row++;\n        }\n\n        return fn(pixels);\n      });\n    }\n  }, {\n    key: 'decodePalette',\n    value: function decodePalette() {\n      var palette = this.palette;\n      var transparency = this.transparency.indexed || [];\n      var ret = new Buffer(transparency.length + palette.length);\n      var pos = 0;\n      var length = palette.length;\n      var c = 0;\n\n      for (var _i = 0, end = palette.length; _i < end; _i += 3) {\n        var left;\n        ret[pos++] = palette[_i];\n        ret[pos++] = palette[_i + 1];\n        ret[pos++] = palette[_i + 2];\n        ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n      }\n\n      return ret;\n    }\n  }, {\n    key: 'copyToImageData',\n    value: function copyToImageData(imageData, pixels) {\n      var j = void 0,\n          k = void 0;\n      var colors = this.colors;\n      var palette = null;\n      var alpha = this.hasAlphaChannel;\n\n      if (this.palette.length) {\n        palette = this._decodedPalette != null ? this._decodedPalette : this._decodedPalette = this.decodePalette();\n        colors = 4;\n        alpha = true;\n      }\n\n      var data = (imageData != null ? imageData.data : undefined) || imageData;\n      var length = data.length;\n      var input = palette || pixels;\n      var i = j = 0;\n\n      if (colors === 1) {\n        while (i < length) {\n          k = palette ? pixels[i / 4] * 4 : j;\n          var v = input[k++];\n          data[i++] = v;\n          data[i++] = v;\n          data[i++] = v;\n          data[i++] = alpha ? input[k++] : 255;\n          j = k;\n        }\n      } else {\n        while (i < length) {\n          k = palette ? pixels[i / 4] * 4 : j;\n          data[i++] = input[k++];\n          data[i++] = input[k++];\n          data[i++] = input[k++];\n          data[i++] = alpha ? input[k++] : 255;\n          j = k;\n        }\n      }\n    }\n  }, {\n    key: 'decode',\n    value: function decode(fn) {\n      var _this4 = this;\n\n      var ret = new Buffer(this.width * this.height * 4);\n      return this.decodePixels(function (pixels) {\n        _this4.copyToImageData(ret, pixels);\n\n        return fn(ret);\n      });\n    }\n  }]);\n  return PNG;\n}();\n\nexport default PNG;","map":{"version":3,"sources":["/Users/pezannekhambatta/Desktop/resumio/node_modules/@react-pdf/png-js/dist/png-js.browser.es.js"],"names":["zlib","range","left","right","inclusive","ascending","end","i","push","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","props","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","toConsumableArray","arr","Array","isArray","arr2","from","PNG","value","decode","path","fn","Error","load","data","_this","pos","palette","imgData","transparency","text","chunkSize","readUInt32","section","result","String","fromCharCode","join","width","height","bits","colorType","compressionMethod","filterMethod","interlaceMethod","read","indexed","short","asc","end1","grayscale","rgb","index","indexOf","apply","slice","colors","hasAlphaChannel","includes","pixelBitlength","colorSpace","Buffer","bytes","_this2","map","b1","b2","b3","b4","readUInt16","decodePixels","_this3","inflate","err","pixelBytes","scanlineLength","pixels","row","c","byte","col","upper","end2","end3","end4","Math","floor","paeth","upperLeft","p","pa","abs","pb","pc","decodePalette","ret","_i","copyToImageData","imageData","j","k","alpha","_decodedPalette","undefined","input","v","_this4"],"mappings":"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","sourcesContent":["import zlib from 'zlib';\n\nvar range = function range(left, right, inclusive) {\n  var range = [];\n  var ascending = left < right;\n  var end = !inclusive ? right : ascending ? right + 1 : right - 1;\n\n  for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n    range.push(i);\n  }\n\n  return range;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar PNG = function () {\n  createClass(PNG, null, [{\n    key: 'decode',\n    value: function decode(path, fn) {\n      {\n        throw new Error('PNG.decode not available in browser build');\n      }\n    }\n  }, {\n    key: 'load',\n    value: function load(path) {\n      {\n        throw new Error('PNG.load not available in browser build');\n      }\n    }\n  }]);\n\n  function PNG(data) {\n    var _this = this;\n\n    classCallCheck(this, PNG);\n\n    var i = void 0;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n\n    while (true) {\n      var end;\n      var chunkSize = this.readUInt32();\n      var section = function () {\n        var result = [];\n        for (i = 0; i < 4; i++) {\n          result.push(String.fromCharCode(_this.data[_this.pos++]));\n        }\n        return result;\n      }().join('');\n\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n\n        case 'IDAT':\n          for (i = 0, end = chunkSize; i < end; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n          break;\n\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n              if (short > 0) {\n                var asc, end1;\n                for (i = 0, end1 = short, asc = 0 <= end1; asc ? i < end1 : i > end1; asc ? i++ : i--) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n              break;\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n          break;\n\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, toConsumableArray(Array.from(text.slice(0, index) || [])));\n          this.text[key] = String.fromCharCode.apply(String, toConsumableArray(Array.from(text.slice(index + 1) || [])));\n          break;\n\n        case 'IEND':\n          // we've got everything we need!\n          this.colors = function () {\n            switch (_this.colorType) {\n              case 0:\n              case 3:\n              case 4:\n                return 1;\n              case 2:\n              case 6:\n                return 3;\n            }\n          }();\n\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n\n          this.colorSpace = function () {\n            switch (_this.colors) {\n              case 1:\n                return 'DeviceGray';\n              case 3:\n                return 'DeviceRGB';\n            }\n          }();\n\n          this.imgData = new Buffer(this.imgData);\n          return;\n          break;\n\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error(\"Incomplete or corrupt PNG file\");\n      }\n    }\n  }\n\n  createClass(PNG, [{\n    key: 'read',\n    value: function read(bytes) {\n      var _this2 = this;\n\n      return range(0, bytes, false).map(function (i) {\n        return _this2.data[_this2.pos++];\n      });\n    }\n  }, {\n    key: 'readUInt32',\n    value: function readUInt32() {\n      var b1 = this.data[this.pos++] << 24;\n      var b2 = this.data[this.pos++] << 16;\n      var b3 = this.data[this.pos++] << 8;\n      var b4 = this.data[this.pos++];\n      return b1 | b2 | b3 | b4;\n    }\n  }, {\n    key: 'readUInt16',\n    value: function readUInt16() {\n      var b1 = this.data[this.pos++] << 8;\n      var b2 = this.data[this.pos++];\n      return b1 | b2;\n    }\n  }, {\n    key: 'decodePixels',\n    value: function decodePixels(fn) {\n      var _this3 = this;\n\n      return zlib.inflate(this.imgData, function (err, data) {\n        if (err) {\n          throw err;\n        }\n\n        var pixelBytes = _this3.pixelBitlength / 8;\n        var scanlineLength = pixelBytes * _this3.width;\n\n        var pixels = new Buffer(scanlineLength * _this3.height);\n        var length = data.length;\n\n        var row = 0;\n        var pos = 0;\n        var c = 0;\n\n        while (pos < length) {\n          var byte, col, i, left, upper;\n          var end;\n          var end1;\n          var end2;\n          var end3;\n          var end4;\n          switch (data[pos++]) {\n            case 0:\n              // None\n              for (i = 0, end = scanlineLength; i < end; i++) {\n                pixels[c++] = data[pos++];\n              }\n              break;\n\n            case 1:\n              // Sub\n              for (i = 0, end1 = scanlineLength; i < end1; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n                pixels[c++] = (byte + left) % 256;\n              }\n              break;\n\n            case 2:\n              // Up\n              for (i = 0, end2 = scanlineLength; i < end2; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                pixels[c++] = (upper + byte) % 256;\n              }\n              break;\n\n            case 3:\n              // Average\n              for (i = 0, end3 = scanlineLength; i < end3; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n                upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                pixels[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n              break;\n\n            case 4:\n              // Paeth\n              for (i = 0, end4 = scanlineLength; i < end4; i++) {\n                var paeth, upperLeft;\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                  upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];\n                }\n\n                var p = left + upper - upperLeft;\n                var pa = Math.abs(p - left);\n                var pb = Math.abs(p - upper);\n                var pc = Math.abs(p - upperLeft);\n\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n\n                pixels[c++] = (byte + paeth) % 256;\n              }\n              break;\n\n            default:\n              throw new Error('Invalid filter algorithm: ' + data[pos - 1]);\n          }\n\n          row++;\n        }\n\n        return fn(pixels);\n      });\n    }\n  }, {\n    key: 'decodePalette',\n    value: function decodePalette() {\n      var palette = this.palette;\n\n      var transparency = this.transparency.indexed || [];\n      var ret = new Buffer(transparency.length + palette.length);\n      var pos = 0;\n      var length = palette.length;\n\n      var c = 0;\n\n      for (var _i = 0, end = palette.length; _i < end; _i += 3) {\n        var left;\n        ret[pos++] = palette[_i];\n        ret[pos++] = palette[_i + 1];\n        ret[pos++] = palette[_i + 2];\n        ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n      }\n\n      return ret;\n    }\n  }, {\n    key: 'copyToImageData',\n    value: function copyToImageData(imageData, pixels) {\n      var j = void 0,\n          k = void 0;\n      var colors = this.colors;\n\n      var palette = null;\n      var alpha = this.hasAlphaChannel;\n\n      if (this.palette.length) {\n        palette = this._decodedPalette != null ? this._decodedPalette : this._decodedPalette = this.decodePalette();\n        colors = 4;\n        alpha = true;\n      }\n\n      var data = (imageData != null ? imageData.data : undefined) || imageData;\n      var length = data.length;\n\n      var input = palette || pixels;\n      var i = j = 0;\n\n      if (colors === 1) {\n        while (i < length) {\n          k = palette ? pixels[i / 4] * 4 : j;\n          var v = input[k++];\n          data[i++] = v;\n          data[i++] = v;\n          data[i++] = v;\n          data[i++] = alpha ? input[k++] : 255;\n          j = k;\n        }\n      } else {\n        while (i < length) {\n          k = palette ? pixels[i / 4] * 4 : j;\n          data[i++] = input[k++];\n          data[i++] = input[k++];\n          data[i++] = input[k++];\n          data[i++] = alpha ? input[k++] : 255;\n          j = k;\n        }\n      }\n    }\n  }, {\n    key: 'decode',\n    value: function decode(fn) {\n      var _this4 = this;\n\n      var ret = new Buffer(this.width * this.height * 4);\n      return this.decodePixels(function (pixels) {\n        _this4.copyToImageData(ret, pixels);\n        return fn(ret);\n      });\n    }\n  }]);\n  return PNG;\n}();\n\nexport default PNG;\n"]},"metadata":{},"sourceType":"module"}