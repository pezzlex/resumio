{"ast":null,"code":"import { convertNumberSkeletonToNumberFormatOptions, isArgumentElement, isDateElement, isDateTimeSkeleton, isLiteralElement, isNumberElement, isNumberSkeleton, isPluralElement, isPoundElement, isSelectElement, isTimeElement, parseDateTimeSkeleton, isTagElement } from 'intl-messageformat-parser';\nimport { MissingValueError, InvalidValueError, FormatError, InvalidValueTypeError } from './error';\nexport var PART_TYPE;\n\n(function (PART_TYPE) {\n  PART_TYPE[PART_TYPE[\"literal\"] = 0] = \"literal\";\n  PART_TYPE[PART_TYPE[\"object\"] = 1] = \"object\";\n})(PART_TYPE || (PART_TYPE = {}));\n\nfunction mergeLiteral(parts) {\n  if (parts.length < 2) {\n    return parts;\n  }\n\n  return parts.reduce(function (all, part) {\n    var lastPart = all[all.length - 1];\n\n    if (!lastPart || lastPart.type !== 0\n    /* literal */\n    || part.type !== 0\n    /* literal */\n    ) {\n        all.push(part);\n      } else {\n      lastPart.value += part.value;\n    }\n\n    return all;\n  }, []);\n}\n\nfunction isFormatXMLElementFn(el) {\n  return typeof el === 'function';\n} // TODO(skeleton): add skeleton support\n\n\nexport function formatToParts(els, locales, formatters, formats, values, currentPluralValue, // For debugging\noriginalMessage) {\n  // Hot path for straight simple msg translations\n  if (els.length === 1 && isLiteralElement(els[0])) {\n    return [{\n      type: 0\n      /* literal */\n      ,\n      value: els[0].value\n    }];\n  }\n\n  var result = [];\n\n  for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {\n    var el = els_1[_i]; // Exit early for string parts.\n\n    if (isLiteralElement(el)) {\n      result.push({\n        type: 0\n        /* literal */\n        ,\n        value: el.value\n      });\n      continue;\n    } // TODO: should this part be literal type?\n    // Replace `#` in plural rules with the actual numeric value.\n\n\n    if (isPoundElement(el)) {\n      if (typeof currentPluralValue === 'number') {\n        result.push({\n          type: 0\n          /* literal */\n          ,\n          value: formatters.getNumberFormat(locales).format(currentPluralValue)\n        });\n      }\n\n      continue;\n    }\n\n    var varName = el.value; // Enforce that all required values are provided by the caller.\n\n    if (!(values && varName in values)) {\n      throw new MissingValueError(varName, originalMessage);\n    }\n\n    var value = values[varName];\n\n    if (isArgumentElement(el)) {\n      if (!value || typeof value === 'string' || typeof value === 'number') {\n        value = typeof value === 'string' || typeof value === 'number' ? String(value) : '';\n      }\n\n      result.push({\n        type: typeof value === 'string' ? 0\n        /* literal */\n        : 1\n        /* object */\n        ,\n        value: value\n      });\n      continue;\n    } // Recursively format plural and select parts' option — which can be a\n    // nested pattern structure. The choosing of the option to use is\n    // abstracted-by and delegated-to the part helper object.\n\n\n    if (isDateElement(el)) {\n      var style = typeof el.style === 'string' ? formats.date[el.style] : isDateTimeSkeleton(el.style) ? parseDateTimeSkeleton(el.style.pattern) : undefined;\n      result.push({\n        type: 0\n        /* literal */\n        ,\n        value: formatters.getDateTimeFormat(locales, style).format(value)\n      });\n      continue;\n    }\n\n    if (isTimeElement(el)) {\n      var style = typeof el.style === 'string' ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? parseDateTimeSkeleton(el.style.pattern) : undefined;\n      result.push({\n        type: 0\n        /* literal */\n        ,\n        value: formatters.getDateTimeFormat(locales, style).format(value)\n      });\n      continue;\n    }\n\n    if (isNumberElement(el)) {\n      var style = typeof el.style === 'string' ? formats.number[el.style] : isNumberSkeleton(el.style) ? convertNumberSkeletonToNumberFormatOptions(el.style.tokens) : undefined;\n      result.push({\n        type: 0\n        /* literal */\n        ,\n        value: formatters.getNumberFormat(locales, style).format(value)\n      });\n      continue;\n    }\n\n    if (isTagElement(el)) {\n      var children = el.children,\n          value_1 = el.value;\n      var formatFn = values[value_1];\n\n      if (!isFormatXMLElementFn(formatFn)) {\n        throw new InvalidValueTypeError(value_1, 'function', originalMessage);\n      }\n\n      var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);\n      var chunks = formatFn.apply(void 0, parts.map(function (p) {\n        return p.value;\n      }));\n\n      if (!Array.isArray(chunks)) {\n        chunks = [chunks];\n      }\n\n      result.push.apply(result, chunks.map(function (c) {\n        return {\n          type: typeof c === 'string' ? 0\n          /* literal */\n          : 1\n          /* object */\n          ,\n          value: c\n        };\n      }));\n    }\n\n    if (isSelectElement(el)) {\n      var opt = el.options[value] || el.options.other;\n\n      if (!opt) {\n        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n      }\n\n      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));\n      continue;\n    }\n\n    if (isPluralElement(el)) {\n      var opt = el.options[\"=\" + value];\n\n      if (!opt) {\n        if (!Intl.PluralRules) {\n          throw new FormatError(\"Intl.PluralRules is not available in this environment.\\nTry polyfilling it using \\\"@formatjs/intl-pluralrules\\\"\\n\", \"MISSING_INTL_API\"\n          /* MISSING_INTL_API */\n          , originalMessage);\n        }\n\n        var rule = formatters.getPluralRules(locales, {\n          type: el.pluralType\n        }).select(value - (el.offset || 0));\n        opt = el.options[rule] || el.options.other;\n      }\n\n      if (!opt) {\n        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n      }\n\n      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));\n      continue;\n    }\n  }\n\n  return mergeLiteral(result);\n}","map":{"version":3,"sources":["../src/formatters.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { convertNumberSkeletonToNumberFormatOptions, isArgumentElement, isDateElement, isDateTimeSkeleton, isLiteralElement, isNumberElement, isNumberSkeleton, isPluralElement, isPoundElement, isSelectElement, isTimeElement, parseDateTimeSkeleton, isTagElement, } from 'intl-messageformat-parser';\nimport { MissingValueError, InvalidValueError, FormatError, InvalidValueTypeError, } from './error';\nexport var PART_TYPE;\n(function (PART_TYPE) {\n    PART_TYPE[PART_TYPE[\"literal\"] = 0] = \"literal\";\n    PART_TYPE[PART_TYPE[\"object\"] = 1] = \"object\";\n})(PART_TYPE || (PART_TYPE = {}));\nfunction mergeLiteral(parts) {\n    if (parts.length < 2) {\n        return parts;\n    }\n    return parts.reduce(function (all, part) {\n        var lastPart = all[all.length - 1];\n        if (!lastPart ||\n            lastPart.type !== 0 /* literal */ ||\n            part.type !== 0 /* literal */) {\n            all.push(part);\n        }\n        else {\n            lastPart.value += part.value;\n        }\n        return all;\n    }, []);\n}\nfunction isFormatXMLElementFn(el) {\n    return typeof el === 'function';\n}\n// TODO(skeleton): add skeleton support\nexport function formatToParts(els, locales, formatters, formats, values, currentPluralValue, \n// For debugging\noriginalMessage) {\n    // Hot path for straight simple msg translations\n    if (els.length === 1 && isLiteralElement(els[0])) {\n        return [\n            {\n                type: 0 /* literal */,\n                value: els[0].value,\n            },\n        ];\n    }\n    var result = [];\n    for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {\n        var el = els_1[_i];\n        // Exit early for string parts.\n        if (isLiteralElement(el)) {\n            result.push({\n                type: 0 /* literal */,\n                value: el.value,\n            });\n            continue;\n        }\n        // TODO: should this part be literal type?\n        // Replace `#` in plural rules with the actual numeric value.\n        if (isPoundElement(el)) {\n            if (typeof currentPluralValue === 'number') {\n                result.push({\n                    type: 0 /* literal */,\n                    value: formatters.getNumberFormat(locales).format(currentPluralValue),\n                });\n            }\n            continue;\n        }\n        var varName = el.value;\n        // Enforce that all required values are provided by the caller.\n        if (!(values && varName in values)) {\n            throw new MissingValueError(varName, originalMessage);\n        }\n        var value = values[varName];\n        if (isArgumentElement(el)) {\n            if (!value || typeof value === 'string' || typeof value === 'number') {\n                value =\n                    typeof value === 'string' || typeof value === 'number'\n                        ? String(value)\n                        : '';\n            }\n            result.push({\n                type: typeof value === 'string' ? 0 /* literal */ : 1 /* object */,\n                value: value,\n            });\n            continue;\n        }\n        // Recursively format plural and select parts' option — which can be a\n        // nested pattern structure. The choosing of the option to use is\n        // abstracted-by and delegated-to the part helper object.\n        if (isDateElement(el)) {\n            var style = typeof el.style === 'string'\n                ? formats.date[el.style]\n                : isDateTimeSkeleton(el.style)\n                    ? parseDateTimeSkeleton(el.style.pattern)\n                    : undefined;\n            result.push({\n                type: 0 /* literal */,\n                value: formatters\n                    .getDateTimeFormat(locales, style)\n                    .format(value),\n            });\n            continue;\n        }\n        if (isTimeElement(el)) {\n            var style = typeof el.style === 'string'\n                ? formats.time[el.style]\n                : isDateTimeSkeleton(el.style)\n                    ? parseDateTimeSkeleton(el.style.pattern)\n                    : undefined;\n            result.push({\n                type: 0 /* literal */,\n                value: formatters\n                    .getDateTimeFormat(locales, style)\n                    .format(value),\n            });\n            continue;\n        }\n        if (isNumberElement(el)) {\n            var style = typeof el.style === 'string'\n                ? formats.number[el.style]\n                : isNumberSkeleton(el.style)\n                    ? convertNumberSkeletonToNumberFormatOptions(el.style.tokens)\n                    : undefined;\n            result.push({\n                type: 0 /* literal */,\n                value: formatters\n                    .getNumberFormat(locales, style)\n                    .format(value),\n            });\n            continue;\n        }\n        if (isTagElement(el)) {\n            var children = el.children, value_1 = el.value;\n            var formatFn = values[value_1];\n            if (!isFormatXMLElementFn(formatFn)) {\n                throw new InvalidValueTypeError(value_1, 'function', originalMessage);\n            }\n            var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);\n            var chunks = formatFn.apply(void 0, parts.map(function (p) { return p.value; }));\n            if (!Array.isArray(chunks)) {\n                chunks = [chunks];\n            }\n            result.push.apply(result, chunks.map(function (c) {\n                return {\n                    type: typeof c === 'string' ? 0 /* literal */ : 1 /* object */,\n                    value: c,\n                };\n            }));\n        }\n        if (isSelectElement(el)) {\n            var opt = el.options[value] || el.options.other;\n            if (!opt) {\n                throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n            }\n            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));\n            continue;\n        }\n        if (isPluralElement(el)) {\n            var opt = el.options[\"=\" + value];\n            if (!opt) {\n                if (!Intl.PluralRules) {\n                    throw new FormatError(\"Intl.PluralRules is not available in this environment.\\nTry polyfilling it using \\\"@formatjs/intl-pluralrules\\\"\\n\", \"MISSING_INTL_API\" /* MISSING_INTL_API */, originalMessage);\n                }\n                var rule = formatters\n                    .getPluralRules(locales, { type: el.pluralType })\n                    .select(value - (el.offset || 0));\n                opt = el.options[rule] || el.options.other;\n            }\n            if (!opt) {\n                throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n            }\n            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));\n            continue;\n        }\n    }\n    return mergeLiteral(result);\n}\n//# sourceMappingURL=formatters.js.map"]},"metadata":{},"sourceType":"module"}