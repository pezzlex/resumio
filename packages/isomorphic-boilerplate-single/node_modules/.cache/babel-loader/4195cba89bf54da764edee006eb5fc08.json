{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _ascent = _interopRequireDefault(require(\"../../run/ascent\"));\n\nvar _ascent2 = _interopRequireDefault(require(\"../../attributedString/ascent\"));\n\nvar _advanceWidth = _interopRequireDefault(require(\"../../run/advanceWidth\"));\n\nvar _advanceWidth2 = _interopRequireDefault(require(\"../../attributedString/advanceWidth\")); // The base font size used for calculating underline thickness.\n\n\nvar BASE_FONT_SIZE = 12;\n/**\n * Computes the intersections between an underline and the glyphs in\n * a line fragment. Returns an array of DecorationLines omitting the\n * intersections.\n */\n// const intersectWithGlyphs = (line, lineFragment) => {\n//   // Find intersection ranges between underline and glyphs\n//   let x = 0;\n//   let y = lineFragment.ascent;\n//   const ranges = [];\n//   for (const run of lineFragment.runs) {\n//     if (!run.attributes.underline) {\n//       x += run.advanceWidth;\n//       continue;\n//     }\n//     for (let i = 0; i < run.glyphs.length; i++) {\n//       const position = run.positions[i];\n//       if (x >= line.rect.x && x <= line.rect.maxX) {\n//         const gx = x + position.xOffset;\n//         const gy = y + position.yOffset;\n//         // Standard fonts may not have a path to intersect with\n//         if (run.glyphs[i].path) {\n//           const path = run.glyphs[i].path.scale(run.scale, -run.scale).translate(gx, gy);\n//           const range = findPathIntersections(path, line.rect);\n//           if (range) {\n//             ranges.push(range);\n//           }\n//         }\n//       }\n//       x += position.xAdvance;\n//       y += position.yAdvance;\n//     }\n//   }\n//   if (ranges.length === 0) {\n//     // No intersections. Return the original line.\n//     return [line];\n//   }\n//   const merged = Range.merge(ranges);\n//   // Generate underline segments omitting the intersections,\n//   // but only if the space warrents an underline.\n//   const lines = [];\n//   x = line.rect.x;\n//   for (const { start, end } of merged) {\n//     if (start - x > line.rect.height) {\n//       lines.push(line.slice(x, start));\n//     }\n//     x = end;\n//   }\n//   if (line.rect.maxX - x > line.rect.height) {\n//     lines.push(line.slice(x, line.rect.maxX));\n//   }\n//   return lines;\n// };\n// const findIntersectionPoint = (y, x1, y1, x2, y2, range) => {\n//   if ((y1 < y && y2 > y) || (y1 > y && y2 < y)) {\n//     const x = x1 + ((y - y1) * (x2 - x1)) / (y2 - y1);\n//     range.extend(x);\n//   }\n// };\n\n/**\n * Finds the intersections between a glyph path and an underline rectangle.\n * It models each contour of the path a straight line, and returns a range\n * containing the leftmost and rightmost intersection points, if any.\n */\n// const findPathIntersections = (path, rect) => {\n//   let sx = 0;\n//   let sy = 0;\n//   let cx = 0;\n//   let cy = 0;\n//   let px = 0;\n//   let py = 0;\n//   const range = new Range(Infinity, -Infinity);\n//   const y1 = rect.y;\n//   const y2 = rect.maxY;\n//   const dialation = Math.ceil(rect.height);\n//   for (const { command, args } of path.commands) {\n//     switch (command) {\n//       case 'moveTo':\n//         sx = cx = args[0];\n//         sy = cy = args[1];\n//         continue;\n//       case 'lineTo':\n//         px = args[0];\n//         py = args[1];\n//         break;\n//       case 'quadraticCurveTo':\n//         px = args[2];\n//         py = args[3];\n//         break;\n//       case 'bezierCurveTo':\n//         px = args[4];\n//         py = args[5];\n//         break;\n//       case 'closePath':\n//         px = sx;\n//         py = sy;\n//         break;\n//       default:\n//         break;\n//     }\n//     findIntersectionPoint(y1, cx, cy, px, py, range);\n//     findIntersectionPoint(y2, cx, cy, px, py, range);\n//     if ((cy >= y1 && cy <= y2) || (cy <= y1 && cy >= y2)) {\n//       range.extend(cx);\n//     }\n//     cx = px;\n//     cy = py;\n//   }\n//   if (range.start < range.end) {\n//     range.start -= dialation;\n//     range.end += dialation;\n//     return range;\n//   }\n//   return null;\n// };\n\n/**\n * A TextDecorationEngine is used by a Typesetter to generate\n * DecorationLines for a line fragment, including underlines\n * and strikes.\n */\n\nvar textDecoration = function textDecoration() {\n  return function (lineFragment) {\n    var x = R.propOr(0, 'overflowLeft', lineFragment);\n    var overflowRight = R.propOr(0, 'overflowRight', lineFragment);\n    var maxX = (0, _advanceWidth2[\"default\"])(lineFragment) - overflowRight;\n    lineFragment.decorationLines = [];\n\n    for (var _iterator = lineFragment.runs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var run = _ref;\n      var width = Math.min(maxX - x, (0, _advanceWidth[\"default\"])(run));\n      var thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\n\n      if (run.attributes.underline) {\n        var rect = {\n          x: x,\n          y: (0, _ascent2[\"default\"])(lineFragment) + thickness * 2,\n          width: width,\n          height: thickness\n        };\n        var line = {\n          rect: rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.underlineColor || 'black',\n          style: run.attributes.underlineStyle || 'solid'\n        };\n        lineFragment.decorationLines.push(line);\n      }\n\n      if (run.attributes.strike) {\n        var y = (0, _ascent2[\"default\"])(lineFragment) - (0, _ascent[\"default\"])(run) / 3;\n        var _rect = {\n          x: x,\n          y: y,\n          width: width,\n          height: thickness\n        };\n        var _line = {\n          rect: _rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.strikeColor || 'black',\n          style: run.attributes.strikeStyle || 'solid'\n        };\n        lineFragment.decorationLines.push(_line);\n      }\n\n      x += width;\n    } // Adjust underline y positions, and intersect with glyph descenders.\n    // for (const line of underlines) {\n    //   lineFragment.decorationLines.push(...intersectWithGlyphs(line, lineFragment));\n    // }\n\n\n    return lineFragment;\n  };\n};\n\nvar _default = textDecoration;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/pezannekhambatta/Desktop/resumio/node_modules/@react-pdf/textkit/engines/textDecoration/index.js"],"names":["_interopRequireDefault","require","_interopRequireWildcard","exports","__esModule","R","_ascent","_ascent2","_advanceWidth","_advanceWidth2","BASE_FONT_SIZE","textDecoration","lineFragment","x","propOr","overflowRight","maxX","decorationLines","_iterator","runs","_isArray","Array","isArray","_i","Symbol","iterator","_ref","length","next","done","value","run","width","Math","min","thickness","max","floor","attributes","fontSize","underline","rect","y","height","line","opacity","color","underlineColor","style","underlineStyle","push","strike","_rect","_line","strikeColor","strikeStyle","_default"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEA,IAAIC,uBAAuB,GAAGD,OAAO,CAAC,+CAAD,CAArC;;AAEAE,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAAC,SAAD,CAAP,GAAqB,KAAK,CAA1B;;AAEA,IAAIE,CAAC,GAAGH,uBAAuB,CAACD,OAAO,CAAC,OAAD,CAAR,CAA/B;;AAEA,IAAIK,OAAO,GAAGN,sBAAsB,CAACC,OAAO,CAAC,kBAAD,CAAR,CAApC;;AAEA,IAAIM,QAAQ,GAAGP,sBAAsB,CAACC,OAAO,CAAC,+BAAD,CAAR,CAArC;;AAEA,IAAIO,aAAa,GAAGR,sBAAsB,CAACC,OAAO,CAAC,wBAAD,CAAR,CAA1C;;AAEA,IAAIQ,cAAc,GAAGT,sBAAsB,CAACC,OAAO,CAAC,qCAAD,CAAR,CAA3C,C,CAEA;;;AACA,IAAIS,cAAc,GAAG,EAArB;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;AAMA,IAAIC,cAAc,GAAG,SAASA,cAAT,GAA0B;AAC7C,SAAO,UAAUC,YAAV,EAAwB;AAC7B,QAAIC,CAAC,GAAGR,CAAC,CAACS,MAAF,CAAS,CAAT,EAA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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _ascent = _interopRequireDefault(require(\"../../run/ascent\"));\n\nvar _ascent2 = _interopRequireDefault(require(\"../../attributedString/ascent\"));\n\nvar _advanceWidth = _interopRequireDefault(require(\"../../run/advanceWidth\"));\n\nvar _advanceWidth2 = _interopRequireDefault(require(\"../../attributedString/advanceWidth\"));\n\n// The base font size used for calculating underline thickness.\nvar BASE_FONT_SIZE = 12;\n/**\n * Computes the intersections between an underline and the glyphs in\n * a line fragment. Returns an array of DecorationLines omitting the\n * intersections.\n */\n// const intersectWithGlyphs = (line, lineFragment) => {\n//   // Find intersection ranges between underline and glyphs\n//   let x = 0;\n//   let y = lineFragment.ascent;\n//   const ranges = [];\n//   for (const run of lineFragment.runs) {\n//     if (!run.attributes.underline) {\n//       x += run.advanceWidth;\n//       continue;\n//     }\n//     for (let i = 0; i < run.glyphs.length; i++) {\n//       const position = run.positions[i];\n//       if (x >= line.rect.x && x <= line.rect.maxX) {\n//         const gx = x + position.xOffset;\n//         const gy = y + position.yOffset;\n//         // Standard fonts may not have a path to intersect with\n//         if (run.glyphs[i].path) {\n//           const path = run.glyphs[i].path.scale(run.scale, -run.scale).translate(gx, gy);\n//           const range = findPathIntersections(path, line.rect);\n//           if (range) {\n//             ranges.push(range);\n//           }\n//         }\n//       }\n//       x += position.xAdvance;\n//       y += position.yAdvance;\n//     }\n//   }\n//   if (ranges.length === 0) {\n//     // No intersections. Return the original line.\n//     return [line];\n//   }\n//   const merged = Range.merge(ranges);\n//   // Generate underline segments omitting the intersections,\n//   // but only if the space warrents an underline.\n//   const lines = [];\n//   x = line.rect.x;\n//   for (const { start, end } of merged) {\n//     if (start - x > line.rect.height) {\n//       lines.push(line.slice(x, start));\n//     }\n//     x = end;\n//   }\n//   if (line.rect.maxX - x > line.rect.height) {\n//     lines.push(line.slice(x, line.rect.maxX));\n//   }\n//   return lines;\n// };\n// const findIntersectionPoint = (y, x1, y1, x2, y2, range) => {\n//   if ((y1 < y && y2 > y) || (y1 > y && y2 < y)) {\n//     const x = x1 + ((y - y1) * (x2 - x1)) / (y2 - y1);\n//     range.extend(x);\n//   }\n// };\n\n/**\n * Finds the intersections between a glyph path and an underline rectangle.\n * It models each contour of the path a straight line, and returns a range\n * containing the leftmost and rightmost intersection points, if any.\n */\n// const findPathIntersections = (path, rect) => {\n//   let sx = 0;\n//   let sy = 0;\n//   let cx = 0;\n//   let cy = 0;\n//   let px = 0;\n//   let py = 0;\n//   const range = new Range(Infinity, -Infinity);\n//   const y1 = rect.y;\n//   const y2 = rect.maxY;\n//   const dialation = Math.ceil(rect.height);\n//   for (const { command, args } of path.commands) {\n//     switch (command) {\n//       case 'moveTo':\n//         sx = cx = args[0];\n//         sy = cy = args[1];\n//         continue;\n//       case 'lineTo':\n//         px = args[0];\n//         py = args[1];\n//         break;\n//       case 'quadraticCurveTo':\n//         px = args[2];\n//         py = args[3];\n//         break;\n//       case 'bezierCurveTo':\n//         px = args[4];\n//         py = args[5];\n//         break;\n//       case 'closePath':\n//         px = sx;\n//         py = sy;\n//         break;\n//       default:\n//         break;\n//     }\n//     findIntersectionPoint(y1, cx, cy, px, py, range);\n//     findIntersectionPoint(y2, cx, cy, px, py, range);\n//     if ((cy >= y1 && cy <= y2) || (cy <= y1 && cy >= y2)) {\n//       range.extend(cx);\n//     }\n//     cx = px;\n//     cy = py;\n//   }\n//   if (range.start < range.end) {\n//     range.start -= dialation;\n//     range.end += dialation;\n//     return range;\n//   }\n//   return null;\n// };\n\n/**\n * A TextDecorationEngine is used by a Typesetter to generate\n * DecorationLines for a line fragment, including underlines\n * and strikes.\n */\n\nvar textDecoration = function textDecoration() {\n  return function (lineFragment) {\n    var x = R.propOr(0, 'overflowLeft', lineFragment);\n    var overflowRight = R.propOr(0, 'overflowRight', lineFragment);\n    var maxX = (0, _advanceWidth2[\"default\"])(lineFragment) - overflowRight;\n    lineFragment.decorationLines = [];\n\n    for (var _iterator = lineFragment.runs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var run = _ref;\n      var width = Math.min(maxX - x, (0, _advanceWidth[\"default\"])(run));\n      var thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\n\n      if (run.attributes.underline) {\n        var rect = {\n          x: x,\n          y: (0, _ascent2[\"default\"])(lineFragment) + thickness * 2,\n          width: width,\n          height: thickness\n        };\n        var line = {\n          rect: rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.underlineColor || 'black',\n          style: run.attributes.underlineStyle || 'solid'\n        };\n        lineFragment.decorationLines.push(line);\n      }\n\n      if (run.attributes.strike) {\n        var y = (0, _ascent2[\"default\"])(lineFragment) - (0, _ascent[\"default\"])(run) / 3;\n        var _rect = {\n          x: x,\n          y: y,\n          width: width,\n          height: thickness\n        };\n        var _line = {\n          rect: _rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.strikeColor || 'black',\n          style: run.attributes.strikeStyle || 'solid'\n        };\n        lineFragment.decorationLines.push(_line);\n      }\n\n      x += width;\n    } // Adjust underline y positions, and intersect with glyph descenders.\n    // for (const line of underlines) {\n    //   lineFragment.decorationLines.push(...intersectWithGlyphs(line, lineFragment));\n    // }\n\n\n    return lineFragment;\n  };\n};\n\nvar _default = textDecoration;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}