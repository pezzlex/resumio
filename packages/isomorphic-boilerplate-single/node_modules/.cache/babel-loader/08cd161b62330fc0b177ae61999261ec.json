{"ast":null,"code":"/*\n * Copyright 2015, Yahoo Inc.\n * Copyrights licensed under the New BSD License.\n * See the accompanying LICENSE file for terms.\n */\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { filterProps, getNamedFormat } from '../utils';\nimport { ReactIntlError } from '../error';\nvar DATE_TIME_FORMAT_OPTIONS = ['localeMatcher', 'formatMatcher', 'timeZone', 'hour12', 'weekday', 'era', 'year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName', 'hourCycle', // 'dateStyle',\n// 'timeStyle',\n'fractionalSecondDigits', 'calendar', // 'dayPeriod',\n'numberingSystem'];\nexport function getFormatter(_a, type, getDateTimeFormat, options) {\n  var locale = _a.locale,\n      formats = _a.formats,\n      onError = _a.onError,\n      timeZone = _a.timeZone;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var format = options.format;\n\n  var defaults = __assign(__assign({}, timeZone && {\n    timeZone: timeZone\n  }), format && getNamedFormat(formats, type, format, onError));\n\n  var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults);\n\n  if (type === 'time' && !filteredOptions.hour && !filteredOptions.minute && !filteredOptions.second) {\n    // Add default formatting options if hour, minute, or second isn't defined.\n    filteredOptions = __assign(__assign({}, filteredOptions), {\n      hour: 'numeric',\n      minute: 'numeric'\n    });\n  }\n\n  return getDateTimeFormat(locale, filteredOptions);\n}\nexport function formatDate(config, getDateTimeFormat, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var date = typeof value === 'string' ? new Date(value || 0) : value;\n\n  try {\n    return getFormatter(config, 'date', getDateTimeFormat, options).format(date);\n  } catch (e) {\n    config.onError(new ReactIntlError(\"FORMAT_ERROR\"\n    /* FORMAT_ERROR */\n    , 'Error formatting date.', e));\n  }\n\n  return String(date);\n}\nexport function formatTime(config, getDateTimeFormat, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var date = typeof value === 'string' ? new Date(value || 0) : value;\n\n  try {\n    return getFormatter(config, 'time', getDateTimeFormat, options).format(date);\n  } catch (e) {\n    config.onError(new ReactIntlError(\"FORMAT_ERROR\"\n    /* FORMAT_ERROR */\n    , 'Error formatting time.', e));\n  }\n\n  return String(date);\n}\nexport function formatDateToParts(config, getDateTimeFormat, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var date = typeof value === 'string' ? new Date(value || 0) : value;\n\n  try {\n    return getFormatter(config, 'date', getDateTimeFormat, options).formatToParts(date);\n  } catch (e) {\n    config.onError(new ReactIntlError(\"FORMAT_ERROR\"\n    /* FORMAT_ERROR */\n    , 'Error formatting date.', e));\n  }\n\n  return [];\n}\nexport function formatTimeToParts(config, getDateTimeFormat, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var date = typeof value === 'string' ? new Date(value || 0) : value;\n\n  try {\n    return getFormatter(config, 'time', getDateTimeFormat, options).formatToParts(date);\n  } catch (e) {\n    config.onError(new ReactIntlError(\"FORMAT_ERROR\"\n    /* FORMAT_ERROR */\n    , 'Error formatting time.', e));\n  }\n\n  return [];\n}","map":{"version":3,"sources":["../../src/formatters/dateTime.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2015, Yahoo Inc.\n * Copyrights licensed under the New BSD License.\n * See the accompanying LICENSE file for terms.\n */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { filterProps, getNamedFormat } from '../utils';\nimport { ReactIntlError } from '../error';\nvar DATE_TIME_FORMAT_OPTIONS = [\n    'localeMatcher',\n    'formatMatcher',\n    'timeZone',\n    'hour12',\n    'weekday',\n    'era',\n    'year',\n    'month',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'timeZoneName',\n    'hourCycle',\n    // 'dateStyle',\n    // 'timeStyle',\n    'fractionalSecondDigits',\n    'calendar',\n    // 'dayPeriod',\n    'numberingSystem',\n];\nexport function getFormatter(_a, type, getDateTimeFormat, options) {\n    var locale = _a.locale, formats = _a.formats, onError = _a.onError, timeZone = _a.timeZone;\n    if (options === void 0) { options = {}; }\n    var format = options.format;\n    var defaults = __assign(__assign({}, (timeZone && { timeZone: timeZone })), (format && getNamedFormat(formats, type, format, onError)));\n    var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults);\n    if (type === 'time' &&\n        !filteredOptions.hour &&\n        !filteredOptions.minute &&\n        !filteredOptions.second) {\n        // Add default formatting options if hour, minute, or second isn't defined.\n        filteredOptions = __assign(__assign({}, filteredOptions), { hour: 'numeric', minute: 'numeric' });\n    }\n    return getDateTimeFormat(locale, filteredOptions);\n}\nexport function formatDate(config, getDateTimeFormat, value, options) {\n    if (options === void 0) { options = {}; }\n    var date = typeof value === 'string' ? new Date(value || 0) : value;\n    try {\n        return getFormatter(config, 'date', getDateTimeFormat, options).format(date);\n    }\n    catch (e) {\n        config.onError(new ReactIntlError(\"FORMAT_ERROR\" /* FORMAT_ERROR */, 'Error formatting date.', e));\n    }\n    return String(date);\n}\nexport function formatTime(config, getDateTimeFormat, value, options) {\n    if (options === void 0) { options = {}; }\n    var date = typeof value === 'string' ? new Date(value || 0) : value;\n    try {\n        return getFormatter(config, 'time', getDateTimeFormat, options).format(date);\n    }\n    catch (e) {\n        config.onError(new ReactIntlError(\"FORMAT_ERROR\" /* FORMAT_ERROR */, 'Error formatting time.', e));\n    }\n    return String(date);\n}\nexport function formatDateToParts(config, getDateTimeFormat, value, options) {\n    if (options === void 0) { options = {}; }\n    var date = typeof value === 'string' ? new Date(value || 0) : value;\n    try {\n        return getFormatter(config, 'date', getDateTimeFormat, options).formatToParts(date);\n    }\n    catch (e) {\n        config.onError(new ReactIntlError(\"FORMAT_ERROR\" /* FORMAT_ERROR */, 'Error formatting date.', e));\n    }\n    return [];\n}\nexport function formatTimeToParts(config, getDateTimeFormat, value, options) {\n    if (options === void 0) { options = {}; }\n    var date = typeof value === 'string' ? new Date(value || 0) : value;\n    try {\n        return getFormatter(config, 'time', getDateTimeFormat, options).formatToParts(date);\n    }\n    catch (e) {\n        config.onError(new ReactIntlError(\"FORMAT_ERROR\" /* FORMAT_ERROR */, 'Error formatting time.', e));\n    }\n    return [];\n}\n//# sourceMappingURL=dateTime.js.map"]},"metadata":{},"sourceType":"module"}