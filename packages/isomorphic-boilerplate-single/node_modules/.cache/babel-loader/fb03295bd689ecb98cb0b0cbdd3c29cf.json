{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _isNumber = _interopRequireDefault(require(\"../utils/isNumber\"));\n/**\n * Generate glyphs indices from string indices\n *\n * ex. resolve([[0, 1, 2, 4]]) => [0, 1, 2, 2, 3]\n *\n * @param  {String}  string\n * @param  {Array}  string indices\n * @return {Array} glyph indices\n */\n\n\nvar resolve = function resolve(string, stringIndices) {\n  if (stringIndices === void 0) {\n    stringIndices = [];\n  }\n\n  var counter = 0;\n  var glyphIndices = [];\n\n  for (var i = 0; i < stringIndices.length; i++) {\n    var current = stringIndices[i];\n    var prevValue = stringIndices[i - 1];\n    var stringIndex = (0, _isNumber[\"default\"])(current) ? current : prevValue + 1 || 0;\n    var nextValue = stringIndices[i + 1] || stringIndex + 1;\n    var diff = Math.abs(nextValue - stringIndex);\n    glyphIndices.push.apply(glyphIndices, R.repeat(counter, diff));\n    counter += 1;\n  } // Append ending ligature glyph indices\n\n\n  if (string.length !== glyphIndices.length) {\n    var _diff = Math.max(0, string.length - glyphIndices.length);\n\n    var lastValue = R.last(glyphIndices);\n    glyphIndices.push.apply(glyphIndices, R.repeat(lastValue, _diff));\n  }\n\n  return glyphIndices;\n};\n\nvar _default = resolve;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/pezannekhambatta/Desktop/resumio/node_modules/@react-pdf/textkit/indices/resolve.js"],"names":["_interopRequireDefault","require","_interopRequireWildcard","exports","__esModule","R","_isNumber","resolve","string","stringIndices","counter","glyphIndices","i","length","current","prevValue","stringIndex","nextValue","diff","Math","abs","push","apply","repeat","_diff","max","lastValue","last","_default"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEA,IAAIC,uBAAuB,GAAGD,OAAO,CAAC,+CAAD,CAArC;;AAEAE,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAAC,SAAD,CAAP,GAAqB,KAAK,CAA1B;;AAEA,IAAIE,CAAC,GAAGH,uBAAuB,CAACD,OAAO,CAAC,OAAD,CAAR,CAA/B;;AAEA,IAAIK,SAAS,GAAGN,sBAAsB,CAACC,OAAO,CAAC,mBAAD,CAAR,CAAtC;AAEA;;;;;;;;;;;AASA,IAAIM,OAAO,GAAG,SAASA,OAAT,CAAiBC,MAAjB,EAAyBC,aAAzB,EAAwC;AACpD,MAAIA,aAAa,KAAK,KAAK,CAA3B,EAA8B;AAC5BA,IAAAA,aAAa,GAAG,EAAhB;AACD;;AAED,MAAIC,OAAO,GAAG,CAAd;AACA,MAAIC,YAAY,GAAG,EAAnB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,aAAa,CAACI,MAAlC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,QAAIE,OAAO,GAAGL,aAAa,CAACG,CAAD,CAA3B;AACA,QAAIG,SAAS,GAAGN,aAAa,CAACG,CAAC,GAAG,CAAL,CAA7B;AACA,QAAII,WAAW,GAAG,CAAC,GAAGV,SAAS,CAAC,SAAD,CAAb,EAA0BQ,OAA1B,IAAqCA,OAArC,GAA+CC,SAAS,GAAG,CAAZ,IAAiB,CAAlF;AACA,QAAIE,SAAS,GAAGR,aAAa,CAACG,CAAC,GAAG,CAAL,CAAb,IAAwBI,WAAW,GAAG,CAAtD;AACA,QAAIE,IAAI,GAAGC,IAAI,CAACC,GAAL,CAASH,SAAS,GAAGD,WAArB,CAAX;AACAL,IAAAA,YAAY,CAACU,IAAb,CAAkBC,KAAlB,CAAwBX,YAAxB,EAAsCN,CAAC,CAACkB,MAAF,CAASb,OAAT,EAAkBQ,IAAlB,CAAtC;AACAR,IAAAA,OAAO,IAAI,CAAX;AACD,GAhBmD,CAgBlD;;;AAGF,MAAIF,MAAM,CAACK,MAAP,KAAkBF,YAAY,CAACE,MAAnC,EAA2C;AACzC,QAAIW,KAAK,GAAGL,IAAI,CAACM,GAAL,CAAS,CAAT,EAAYjB,MAAM,CAACK,MAAP,GAAgBF,YAAY,CAACE,MAAzC,CAAZ;;AAEA,QAAIa,SAAS,GAAGrB,CAAC,CAACsB,IAAF,CAAOhB,YAAP,CAAhB;AACAA,IAAAA,YAAY,CAACU,IAAb,CAAkBC,KAAlB,CAAwBX,YAAxB,EAAsCN,CAAC,CAACkB,MAAF,CAASG,SAAT,EAAoBF,KAApB,CAAtC;AACD;;AAED,SAAOb,YAAP;AACD,CA3BD;;AA6BA,IAAIiB,QAAQ,GAAGrB,OAAf;AACAJ,OAAO,CAAC,SAAD,CAAP,GAAqByB,QAArB","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _isNumber = _interopRequireDefault(require(\"../utils/isNumber\"));\n\n/**\n * Generate glyphs indices from string indices\n *\n * ex. resolve([[0, 1, 2, 4]]) => [0, 1, 2, 2, 3]\n *\n * @param  {String}  string\n * @param  {Array}  string indices\n * @return {Array} glyph indices\n */\nvar resolve = function resolve(string, stringIndices) {\n  if (stringIndices === void 0) {\n    stringIndices = [];\n  }\n\n  var counter = 0;\n  var glyphIndices = [];\n\n  for (var i = 0; i < stringIndices.length; i++) {\n    var current = stringIndices[i];\n    var prevValue = stringIndices[i - 1];\n    var stringIndex = (0, _isNumber[\"default\"])(current) ? current : prevValue + 1 || 0;\n    var nextValue = stringIndices[i + 1] || stringIndex + 1;\n    var diff = Math.abs(nextValue - stringIndex);\n    glyphIndices.push.apply(glyphIndices, R.repeat(counter, diff));\n    counter += 1;\n  } // Append ending ligature glyph indices\n\n\n  if (string.length !== glyphIndices.length) {\n    var _diff = Math.max(0, string.length - glyphIndices.length);\n\n    var lastValue = R.last(glyphIndices);\n    glyphIndices.push.apply(glyphIndices, R.repeat(lastValue, _diff));\n  }\n\n  return glyphIndices;\n};\n\nvar _default = resolve;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}