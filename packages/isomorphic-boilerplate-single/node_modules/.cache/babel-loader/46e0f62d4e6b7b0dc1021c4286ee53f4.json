{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _fromFragments = _interopRequireDefault(require(\"../attributedString/fromFragments\"));\n/**\n * Default word hyphenation engine used when no one provided.\n * Does not perform word hyphenation at all\n *\n * @param  {String} word\n * @return {Array} same word\n */\n\n\nvar defaultHyphenationEngine = function defaultHyphenationEngine(word) {\n  return [word];\n};\n/**\n * Wrap words of attribute string\n *\n * @param  {Object} layout engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string including syllables\n */\n\n\nvar wrapWords = function wrapWords(engines, options, attributedString) {\n  if (engines === void 0) {\n    engines = {};\n  }\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var syllables = [];\n  var fragments = [];\n  var hyphenateWord = options.hyphenationCallback || engines.wordHyphenation && engines.wordHyphenation(options) || defaultHyphenationEngine;\n\n  for (var _iterator = attributedString.runs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var run = _ref;\n    var string = '';\n    var words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);\n\n    for (var _iterator2 = words, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var word = _ref2;\n      var parts = hyphenateWord(word);\n      syllables.push.apply(syllables, parts);\n      string += parts.join('');\n    }\n\n    fragments.push({\n      string: string,\n      attributes: run.attributes\n    });\n  }\n\n  return (0, _extends2[\"default\"])({}, (0, _fromFragments[\"default\"])(fragments), {\n    syllables: syllables\n  });\n};\n\nvar _default = R.curryN(3, wrapWords);\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/pezannekhambatta/Desktop/resumio/node_modules/@react-pdf/textkit/layout/wrapWords.js"],"names":["_interopRequireWildcard","require","_interopRequireDefault","exports","__esModule","_extends2","R","_fromFragments","defaultHyphenationEngine","word","wrapWords","engines","options","attributedString","syllables","fragments","hyphenateWord","hyphenationCallback","wordHyphenation","_iterator","runs","_isArray","Array","isArray","_i","Symbol","iterator","_ref","length","next","done","value","run","string","words","slice","start","end","split","filter","Boolean","_iterator2","_isArray2","_i2","_ref2","parts","push","apply","join","attributes","_default","curryN"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _fromFragments = _interopRequireDefault(require(\"../attributedString/fromFragments\"));\n\n/**\n * Default word hyphenation engine used when no one provided.\n * Does not perform word hyphenation at all\n *\n * @param  {String} word\n * @return {Array} same word\n */\nvar defaultHyphenationEngine = function defaultHyphenationEngine(word) {\n  return [word];\n};\n/**\n * Wrap words of attribute string\n *\n * @param  {Object} layout engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string including syllables\n */\n\n\nvar wrapWords = function wrapWords(engines, options, attributedString) {\n  if (engines === void 0) {\n    engines = {};\n  }\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var syllables = [];\n  var fragments = [];\n  var hyphenateWord = options.hyphenationCallback || engines.wordHyphenation && engines.wordHyphenation(options) || defaultHyphenationEngine;\n\n  for (var _iterator = attributedString.runs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var run = _ref;\n    var string = '';\n    var words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);\n\n    for (var _iterator2 = words, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var word = _ref2;\n      var parts = hyphenateWord(word);\n      syllables.push.apply(syllables, parts);\n      string += parts.join('');\n    }\n\n    fragments.push({\n      string: string,\n      attributes: run.attributes\n    });\n  }\n\n  return (0, _extends2[\"default\"])({}, (0, _fromFragments[\"default\"])(fragments), {\n    syllables: syllables\n  });\n};\n\nvar _default = R.curryN(3, wrapWords);\n\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}