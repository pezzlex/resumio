{"ast":null,"code":"import _regeneratorRuntime from 'babel-runtime/regenerator';\nimport _asyncToGenerator from 'babel-runtime/helpers/asyncToGenerator';\nvar _this = undefined; // Default presence ahead function. Used when node does not provides one.\n\nvar defaultPresenceAhead = function defaultPresenceAhead(element) {\n  return function (height) {\n    return Math.min(element.height, height);\n  };\n}; // Calculates the presence ahead or an array of nodes, given the available height.\n\n\nvar getPresenceAhead = function getPresenceAhead(elements, height) {\n  var result = 0;\n\n  for (var i = 0; i < elements.length; i++) {\n    var element = elements[i];\n    var isElementInside = height > element.top;\n    var presenceAhead = element.presenceAhead || defaultPresenceAhead(element);\n\n    if (element && isElementInside) {\n      result += presenceAhead(height - element.top);\n    }\n  }\n\n  return result;\n}; // Clone element recursively including children\n\n\nvar cloneRecursively = function cloneRecursively(node) {\n  var clone = node.clone();\n\n  if (node.children && node.children.length > 0) {\n    node.children.forEach(function (child) {\n      return clone.appendChild(cloneRecursively(child));\n    });\n  }\n\n  return clone;\n}; // Wrap nodes tree in fixed height page, and returns exceedings separately.\n\n\nvar wrap = function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(elements, height, pageNumber) {\n    var nextPageElements, elementsToBeRemoved, i, element, futureElements, isElementOutside, elementShouldSplit, elementShouldBreak, presenceAhead, clone, newFutureElements, nonFixedElements, _ret;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            nextPageElements = [];\n            elementsToBeRemoved = [];\n            i = 0;\n\n          case 3:\n            if (!(i < elements.length)) {\n              _context2.next = 37;\n              break;\n            }\n\n            element = elements[i];\n\n            if (!element.nodeWillWrap) {\n              _context2.next = 8;\n              break;\n            }\n\n            _context2.next = 8;\n            return element.nodeWillWrap({\n              pageNumber: pageNumber\n            });\n\n          case 8:\n            futureElements = elements.slice(i + 1);\n            isElementOutside = height <= element.top;\n            elementShouldSplit = height < element.top + element.height;\n            elementShouldBreak = element.break || !element.wrap && elementShouldSplit; // If element is fixed, we add it both to the current page\n            // and to all future pages to come.\n\n            if (!element.fixed) {\n              _context2.next = 15;\n              break;\n            }\n\n            nextPageElements.push(cloneRecursively(element));\n            return _context2.abrupt(\"continue\", 34);\n\n          case 15:\n            if (!isElementOutside) {\n              _context2.next = 19;\n              break;\n            }\n\n            nextPageElements.push(cloneRecursively(element));\n            elementsToBeRemoved.push(element);\n            return _context2.abrupt(\"continue\", 34);\n\n          case 19:\n            // Checks if element has more than the minimun presence ahead on that page.\n            // If not, we break the page in this element.\n            if (element.minPresenceAhead) {\n              presenceAhead = getPresenceAhead(futureElements, height);\n              if (presenceAhead < element.minPresenceAhead) elementShouldBreak = true;\n            } // Element can break based on many conditions: if has the break flag,\n            // if has the wrap flag as false and should be splitted or didn't have enough\n            // presence ahead. Either way, the element get's relocated on the next page,\n            // as well as all other next elements.\n\n\n            if (!elementShouldBreak) {\n              _context2.next = 29;\n              break;\n            }\n\n            clone = cloneRecursively(element);\n            newFutureElements = futureElements.map(function (element) {\n              return cloneRecursively(element);\n            });\n            nonFixedElements = futureElements.filter(function (element) {\n              return !element.fixed;\n            });\n            clone.top = 0;\n            clone.break = false;\n            nextPageElements.push.apply(nextPageElements, [clone].concat(newFutureElements));\n            elementsToBeRemoved.push.apply(elementsToBeRemoved, [element].concat(nonFixedElements));\n            return _context2.abrupt(\"break\", 37);\n\n          case 29:\n            if (!elementShouldSplit) {\n              _context2.next = 34;\n              break;\n            }\n\n            return _context2.delegateYield( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n              var clone, remainingHeight, wrappedChildren;\n              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      clone = element.clone();\n                      remainingHeight = height - element.top;\n\n                      if (!(element.children && element.children.length > 0)) {\n                        _context.next = 7;\n                        break;\n                      }\n\n                      _context.next = 5;\n                      return wrap(element.children, remainingHeight);\n\n                    case 5:\n                      wrappedChildren = _context.sent;\n                      wrappedChildren.forEach(function (child) {\n                        return clone.appendChild(child);\n                      });\n\n                    case 7:\n                      element.onNodeSplit(remainingHeight, clone);\n                      nextPageElements.push(clone);\n                      return _context.abrupt(\"return\", \"continue\");\n\n                    case 10:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee, _this);\n            })(), \"t0\", 31);\n\n          case 31:\n            _ret = _context2.t0;\n\n            if (!(_ret === \"continue\")) {\n              _context2.next = 34;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 34);\n\n          case 34:\n            i++;\n            _context2.next = 3;\n            break;\n\n          case 37:\n            // Remove elements that didn't fit inside page\n            // We do this here to not interfer with upper elements iteration\n            elementsToBeRemoved.forEach(function (element) {\n              return element.remove();\n            });\n            return _context2.abrupt(\"return\", nextPageElements);\n\n          case 39:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, _this);\n  }));\n\n  return function wrap(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}(); // Wrap nodes tree in equal sized subpages\n\n\nvar wrapPages = function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(nodes, height, pageIndex) {\n    var wrapResult, nextPage, hasOnlyFixedChilds, nextPages;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return wrap(nodes, height, pageIndex++);\n\n          case 2:\n            wrapResult = _context3.sent;\n            nextPage = wrapResult[0];\n\n            if (!(!nextPage || nextPage.isEmpty())) {\n              _context3.next = 6;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", nodes);\n\n          case 6:\n            hasOnlyFixedChilds = nextPage.children.length > 0 && nextPage.children.every(function (c) {\n              return c.fixed;\n            });\n\n            if (!hasOnlyFixedChilds) {\n              _context3.next = 9;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", nodes);\n\n          case 9:\n            _context3.next = 11;\n            return wrapPages([nextPage], height, pageIndex);\n\n          case 11:\n            nextPages = _context3.sent;\n            return _context3.abrupt(\"return\", [].concat(nodes, nextPages));\n\n          case 13:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, _this);\n  }));\n\n  return function wrapPages(_x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar wrapPage = function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(page, height) {\n    var pageIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var pages;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (page) {\n              _context4.next = 2;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", []);\n\n          case 2:\n            _context4.next = 4;\n            return wrapPages([cloneRecursively(page)], height, pageIndex);\n\n          case 4:\n            pages = _context4.sent;\n            return _context4.abrupt(\"return\", pages);\n\n          case 6:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, _this);\n  }));\n\n  return function wrapPage(_x8, _x9) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nexport { wrap };\nexport default wrapPage;","map":{"version":3,"sources":["/Users/pezannekhambatta/Desktop/resumio/node_modules/page-wrapping/dist/page-wrapping.es.js"],"names":["_regeneratorRuntime","_asyncToGenerator","_this","undefined","defaultPresenceAhead","element","height","Math","min","getPresenceAhead","elements","result","i","length","isElementInside","top","presenceAhead","cloneRecursively","node","clone","children","forEach","child","appendChild","wrap","_ref","mark","_callee2","pageNumber","nextPageElements","elementsToBeRemoved","futureElements","isElementOutside","elementShouldSplit","elementShouldBreak","newFutureElements","nonFixedElements","_ret","_callee2$","_context2","prev","next","nodeWillWrap","slice","break","fixed","push","abrupt","minPresenceAhead","map","filter","apply","concat","delegateYield","_callee","remainingHeight","wrappedChildren","_callee$","_context","sent","onNodeSplit","stop","t0","remove","_x","_x2","_x3","arguments","wrapPages","_ref2","_callee3","nodes","pageIndex","wrapResult","nextPage","hasOnlyFixedChilds","nextPages","_callee3$","_context3","isEmpty","every","c","_x4","_x5","_x6","wrapPage","_ref3","_callee4","page","pages","_callee4$","_context4","_x8","_x9"],"mappings":"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","sourcesContent":["import _regeneratorRuntime from 'babel-runtime/regenerator';\nimport _asyncToGenerator from 'babel-runtime/helpers/asyncToGenerator';\n\nvar _this = undefined;\n\n// Default presence ahead function. Used when node does not provides one.\nvar defaultPresenceAhead = function defaultPresenceAhead(element) {\n  return function (height) {\n    return Math.min(element.height, height);\n  };\n};\n\n// Calculates the presence ahead or an array of nodes, given the available height.\nvar getPresenceAhead = function getPresenceAhead(elements, height) {\n  var result = 0;\n\n  for (var i = 0; i < elements.length; i++) {\n    var element = elements[i];\n    var isElementInside = height > element.top;\n    var presenceAhead = element.presenceAhead || defaultPresenceAhead(element);\n\n    if (element && isElementInside) {\n      result += presenceAhead(height - element.top);\n    }\n  }\n\n  return result;\n};\n\n// Clone element recursively including children\nvar cloneRecursively = function cloneRecursively(node) {\n  var clone = node.clone();\n\n  if (node.children && node.children.length > 0) {\n    node.children.forEach(function (child) {\n      return clone.appendChild(cloneRecursively(child));\n    });\n  }\n\n  return clone;\n};\n\n// Wrap nodes tree in fixed height page, and returns exceedings separately.\nvar wrap = function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(elements, height, pageNumber) {\n    var nextPageElements, elementsToBeRemoved, i, element, futureElements, isElementOutside, elementShouldSplit, elementShouldBreak, presenceAhead, clone, newFutureElements, nonFixedElements, _ret;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            nextPageElements = [];\n            elementsToBeRemoved = [];\n            i = 0;\n\n          case 3:\n            if (!(i < elements.length)) {\n              _context2.next = 37;\n              break;\n            }\n\n            element = elements[i];\n\n            if (!element.nodeWillWrap) {\n              _context2.next = 8;\n              break;\n            }\n\n            _context2.next = 8;\n            return element.nodeWillWrap({ pageNumber: pageNumber });\n\n          case 8:\n            futureElements = elements.slice(i + 1);\n            isElementOutside = height <= element.top;\n            elementShouldSplit = height < element.top + element.height;\n            elementShouldBreak = element.break || !element.wrap && elementShouldSplit;\n\n            // If element is fixed, we add it both to the current page\n            // and to all future pages to come.\n\n            if (!element.fixed) {\n              _context2.next = 15;\n              break;\n            }\n\n            nextPageElements.push(cloneRecursively(element));\n            return _context2.abrupt(\"continue\", 34);\n\n          case 15:\n            if (!isElementOutside) {\n              _context2.next = 19;\n              break;\n            }\n\n            nextPageElements.push(cloneRecursively(element));\n            elementsToBeRemoved.push(element);\n            return _context2.abrupt(\"continue\", 34);\n\n          case 19:\n\n            // Checks if element has more than the minimun presence ahead on that page.\n            // If not, we break the page in this element.\n            if (element.minPresenceAhead) {\n              presenceAhead = getPresenceAhead(futureElements, height);\n\n              if (presenceAhead < element.minPresenceAhead) elementShouldBreak = true;\n            }\n\n            // Element can break based on many conditions: if has the break flag,\n            // if has the wrap flag as false and should be splitted or didn't have enough\n            // presence ahead. Either way, the element get's relocated on the next page,\n            // as well as all other next elements.\n\n            if (!elementShouldBreak) {\n              _context2.next = 29;\n              break;\n            }\n\n            clone = cloneRecursively(element);\n            newFutureElements = futureElements.map(function (element) {\n              return cloneRecursively(element);\n            });\n            nonFixedElements = futureElements.filter(function (element) {\n              return !element.fixed;\n            });\n\n\n            clone.top = 0;\n            clone.break = false;\n\n            nextPageElements.push.apply(nextPageElements, [clone].concat(newFutureElements));\n            elementsToBeRemoved.push.apply(elementsToBeRemoved, [element].concat(nonFixedElements));\n            return _context2.abrupt(\"break\", 37);\n\n          case 29:\n            if (!elementShouldSplit) {\n              _context2.next = 34;\n              break;\n            }\n\n            return _context2.delegateYield( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n              var clone, remainingHeight, wrappedChildren;\n              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      clone = element.clone();\n                      remainingHeight = height - element.top;\n\n                      if (!(element.children && element.children.length > 0)) {\n                        _context.next = 7;\n                        break;\n                      }\n\n                      _context.next = 5;\n                      return wrap(element.children, remainingHeight);\n\n                    case 5:\n                      wrappedChildren = _context.sent;\n\n                      wrappedChildren.forEach(function (child) {\n                        return clone.appendChild(child);\n                      });\n\n                    case 7:\n\n                      element.onNodeSplit(remainingHeight, clone);\n                      nextPageElements.push(clone);\n\n                      return _context.abrupt(\"return\", \"continue\");\n\n                    case 10:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee, _this);\n            })(), \"t0\", 31);\n\n          case 31:\n            _ret = _context2.t0;\n\n            if (!(_ret === \"continue\")) {\n              _context2.next = 34;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 34);\n\n          case 34:\n            i++;\n            _context2.next = 3;\n            break;\n\n          case 37:\n\n            // Remove elements that didn't fit inside page\n            // We do this here to not interfer with upper elements iteration\n            elementsToBeRemoved.forEach(function (element) {\n              return element.remove();\n            });\n\n            return _context2.abrupt(\"return\", nextPageElements);\n\n          case 39:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, _this);\n  }));\n\n  return function wrap(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n// Wrap nodes tree in equal sized subpages\nvar wrapPages = function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(nodes, height, pageIndex) {\n    var wrapResult, nextPage, hasOnlyFixedChilds, nextPages;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return wrap(nodes, height, pageIndex++);\n\n          case 2:\n            wrapResult = _context3.sent;\n            nextPage = wrapResult[0];\n\n            if (!(!nextPage || nextPage.isEmpty())) {\n              _context3.next = 6;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", nodes);\n\n          case 6:\n            hasOnlyFixedChilds = nextPage.children.length > 0 && nextPage.children.every(function (c) {\n              return c.fixed;\n            });\n\n            if (!hasOnlyFixedChilds) {\n              _context3.next = 9;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", nodes);\n\n          case 9:\n            _context3.next = 11;\n            return wrapPages([nextPage], height, pageIndex);\n\n          case 11:\n            nextPages = _context3.sent;\n            return _context3.abrupt(\"return\", [].concat(nodes, nextPages));\n\n          case 13:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, _this);\n  }));\n\n  return function wrapPages(_x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar wrapPage = function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(page, height) {\n    var pageIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var pages;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (page) {\n              _context4.next = 2;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", []);\n\n          case 2:\n            _context4.next = 4;\n            return wrapPages([cloneRecursively(page)], height, pageIndex);\n\n          case 4:\n            pages = _context4.sent;\n            return _context4.abrupt(\"return\", pages);\n\n          case 6:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, _this);\n  }));\n\n  return function wrapPage(_x8, _x9) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nexport { wrap };\nexport default wrapPage;\n"]},"metadata":{},"sourceType":"module"}