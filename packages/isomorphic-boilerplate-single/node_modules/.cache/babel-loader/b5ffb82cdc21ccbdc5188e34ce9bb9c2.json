{"ast":null,"code":"// Generated by CoffeeScript 1.7.1\n(function () {\n  var Struct, utils;\n  utils = require('./utils');\n\n  Struct = function () {\n    function Struct(fields) {\n      this.fields = fields != null ? fields : {};\n    }\n\n    Struct.prototype.decode = function (stream, parent, length) {\n      var res, _ref;\n\n      if (length == null) {\n        length = 0;\n      }\n\n      res = this._setup(stream, parent, length);\n\n      this._parseFields(stream, res, this.fields);\n\n      if ((_ref = this.process) != null) {\n        _ref.call(res, stream);\n      }\n\n      return res;\n    };\n\n    Struct.prototype._setup = function (stream, parent, length) {\n      var res;\n      res = {};\n      Object.defineProperties(res, {\n        parent: {\n          value: parent\n        },\n        _startOffset: {\n          value: stream.pos\n        },\n        _currentOffset: {\n          value: 0,\n          writable: true\n        },\n        _length: {\n          value: length\n        }\n      });\n      return res;\n    };\n\n    Struct.prototype._parseFields = function (stream, res, fields) {\n      var key, type, val;\n\n      for (key in fields) {\n        type = fields[key];\n\n        if (typeof type === 'function') {\n          val = type.call(res, res);\n        } else {\n          val = type.decode(stream, res);\n        }\n\n        if (val !== void 0) {\n          if (val instanceof utils.PropertyDescriptor) {\n            Object.defineProperty(res, key, val);\n          } else {\n            res[key] = val;\n          }\n        }\n\n        res._currentOffset = stream.pos - res._startOffset;\n      }\n    };\n\n    Struct.prototype.size = function (val, parent, includePointers) {\n      var ctx, key, size, type, _ref;\n\n      if (val == null) {\n        val = {};\n      }\n\n      if (includePointers == null) {\n        includePointers = true;\n      }\n\n      ctx = {\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      size = 0;\n      _ref = this.fields;\n\n      for (key in _ref) {\n        type = _ref[key];\n\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n\n      if (includePointers) {\n        size += ctx.pointerSize;\n      }\n\n      return size;\n    };\n\n    Struct.prototype.encode = function (stream, val, parent) {\n      var ctx, i, key, ptr, type, _ref, _ref1;\n\n      if ((_ref = this.preEncode) != null) {\n        _ref.call(val, stream);\n      }\n\n      ctx = {\n        pointers: [],\n        startOffset: stream.pos,\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n      _ref1 = this.fields;\n\n      for (key in _ref1) {\n        type = _ref1[key];\n\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n\n      i = 0;\n\n      while (i < ctx.pointers.length) {\n        ptr = ctx.pointers[i++];\n        ptr.type.encode(stream, ptr.val, ptr.parent);\n      }\n    };\n\n    return Struct;\n  }();\n\n  module.exports = Struct;\n}).call(this);","map":{"version":3,"sources":["/Users/pezannekhambatta/Desktop/resumio/node_modules/restructure/src/Struct.js"],"names":["Struct","utils","require","fields","prototype","decode","stream","parent","length","res","_ref","_setup","_parseFields","process","call","Object","defineProperties","value","_startOffset","pos","_currentOffset","writable","_length","key","type","val","PropertyDescriptor","defineProperty","size","includePointers","ctx","pointerSize","encode","i","ptr","_ref1","preEncode","pointers","startOffset","pointerOffset","module","exports"],"mappings":"AAAA;AACA,CAAC,YAAW;AACV,MAAIA,MAAJ,EAAYC,KAAZ;AAEAA,EAAAA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAAf;;AAEAF,EAAAA,MAAM,GAAI,YAAW;AACnB,aAASA,MAAT,CAAgBG,MAAhB,EAAwB;AACtB,WAAKA,MAAL,GAAcA,MAAM,IAAI,IAAV,GAAiBA,MAAjB,GAA0B,EAAxC;AACD;;AAEDH,IAAAA,MAAM,CAACI,SAAP,CAAiBC,MAAjB,GAA0B,UAASC,MAAT,EAAiBC,MAAjB,EAAyBC,MAAzB,EAAiC;AACzD,UAAIC,GAAJ,EAASC,IAAT;;AACA,UAAIF,MAAM,IAAI,IAAd,EAAoB;AAClBA,QAAAA,MAAM,GAAG,CAAT;AACD;;AACDC,MAAAA,GAAG,GAAG,KAAKE,MAAL,CAAYL,MAAZ,EAAoBC,MAApB,EAA4BC,MAA5B,CAAN;;AACA,WAAKI,YAAL,CAAkBN,MAAlB,EAA0BG,GAA1B,EAA+B,KAAKN,MAApC;;AACA,UAAI,CAACO,IAAI,GAAG,KAAKG,OAAb,KAAyB,IAA7B,EAAmC;AACjCH,QAAAA,IAAI,CAACI,IAAL,CAAUL,GAAV,EAAeH,MAAf;AACD;;AACD,aAAOG,GAAP;AACD,KAXD;;AAaAT,IAAAA,MAAM,CAACI,SAAP,CAAiBO,MAAjB,GAA0B,UAASL,MAAT,EAAiBC,MAAjB,EAAyBC,MAAzB,EAAiC;AACzD,UAAIC,GAAJ;AACAA,MAAAA,GAAG,GAAG,EAAN;AACAM,MAAAA,MAAM,CAACC,gBAAP,CAAwBP,GAAxB,EAA6B;AAC3BF,QAAAA,MAAM,EAAE;AACNU,UAAAA,KAAK,EAAEV;AADD,SADmB;AAI3BW,QAAAA,YAAY,EAAE;AACZD,UAAAA,KAAK,EAAEX,MAAM,CAACa;AADF,SAJa;AAO3BC,QAAAA,cAAc,EAAE;AACdH,UAAAA,KAAK,EAAE,CADO;AAEdI,UAAAA,QAAQ,EAAE;AAFI,SAPW;AAW3BC,QAAAA,OAAO,EAAE;AACPL,UAAAA,KAAK,EAAET;AADA;AAXkB,OAA7B;AAeA,aAAOC,GAAP;AACD,KAnBD;;AAqBAT,IAAAA,MAAM,CAACI,SAAP,CAAiBQ,YAAjB,GAAgC,UAASN,MAAT,EAAiBG,GAAjB,EAAsBN,MAAtB,EAA8B;AAC5D,UAAIoB,GAAJ,EAASC,IAAT,EAAeC,GAAf;;AACA,WAAKF,GAAL,IAAYpB,MAAZ,EAAoB;AAClBqB,QAAAA,IAAI,GAAGrB,MAAM,CAACoB,GAAD,CAAb;;AACA,YAAI,OAAOC,IAAP,KAAgB,UAApB,EAAgC;AAC9BC,UAAAA,GAAG,GAAGD,IAAI,CAACV,IAAL,CAAUL,GAAV,EAAeA,GAAf,CAAN;AACD,SAFD,MAEO;AACLgB,UAAAA,GAAG,GAAGD,IAAI,CAACnB,MAAL,CAAYC,MAAZ,EAAoBG,GAApB,CAAN;AACD;;AACD,YAAIgB,GAAG,KAAK,KAAK,CAAjB,EAAoB;AAClB,cAAIA,GAAG,YAAYxB,KAAK,CAACyB,kBAAzB,EAA6C;AAC3CX,YAAAA,MAAM,CAACY,cAAP,CAAsBlB,GAAtB,EAA2Bc,GAA3B,EAAgCE,GAAhC;AACD,WAFD,MAEO;AACLhB,YAAAA,GAAG,CAACc,GAAD,CAAH,GAAWE,GAAX;AACD;AACF;;AACDhB,QAAAA,GAAG,CAACW,cAAJ,GAAqBd,MAAM,CAACa,GAAP,GAAaV,GAAG,CAACS,YAAtC;AACD;AACF,KAlBD;;AAoBAlB,IAAAA,MAAM,CAACI,SAAP,CAAiBwB,IAAjB,GAAwB,UAASH,GAAT,EAAclB,MAAd,EAAsBsB,eAAtB,EAAuC;AAC7D,UAAIC,GAAJ,EAASP,GAAT,EAAcK,IAAd,EAAoBJ,IAApB,EAA0Bd,IAA1B;;AACA,UAAIe,GAAG,IAAI,IAAX,EAAiB;AACfA,QAAAA,GAAG,GAAG,EAAN;AACD;;AACD,UAAII,eAAe,IAAI,IAAvB,EAA6B;AAC3BA,QAAAA,eAAe,GAAG,IAAlB;AACD;;AACDC,MAAAA,GAAG,GAAG;AACJvB,QAAAA,MAAM,EAAEA,MADJ;AAEJkB,QAAAA,GAAG,EAAEA,GAFD;AAGJM,QAAAA,WAAW,EAAE;AAHT,OAAN;AAKAH,MAAAA,IAAI,GAAG,CAAP;AACAlB,MAAAA,IAAI,GAAG,KAAKP,MAAZ;;AACA,WAAKoB,GAAL,IAAYb,IAAZ,EAAkB;AAChBc,QAAAA,IAAI,GAAGd,IAAI,CAACa,GAAD,CAAX;;AACA,YAAIC,IAAI,CAACI,IAAL,IAAa,IAAjB,EAAuB;AACrBA,UAAAA,IAAI,IAAIJ,IAAI,CAACI,IAAL,CAAUH,GAAG,CAACF,GAAD,CAAb,EAAoBO,GAApB,CAAR;AACD;AACF;;AACD,UAAID,eAAJ,EAAqB;AACnBD,QAAAA,IAAI,IAAIE,GAAG,CAACC,WAAZ;AACD;;AACD,aAAOH,IAAP;AACD,KAzBD;;AA2BA5B,IAAAA,MAAM,CAACI,SAAP,CAAiB4B,MAAjB,GAA0B,UAAS1B,MAAT,EAAiBmB,GAAjB,EAAsBlB,MAAtB,EAA8B;AACtD,UAAIuB,GAAJ,EAASG,CAAT,EAAYV,GAAZ,EAAiBW,GAAjB,EAAsBV,IAAtB,EAA4Bd,IAA5B,EAAkCyB,KAAlC;;AACA,UAAI,CAACzB,IAAI,GAAG,KAAK0B,SAAb,KAA2B,IAA/B,EAAqC;AACnC1B,QAAAA,IAAI,CAACI,IAAL,CAAUW,GAAV,EAAenB,MAAf;AACD;;AACDwB,MAAAA,GAAG,GAAG;AACJO,QAAAA,QAAQ,EAAE,EADN;AAEJC,QAAAA,WAAW,EAAEhC,MAAM,CAACa,GAFhB;AAGJZ,QAAAA,MAAM,EAAEA,MAHJ;AAIJkB,QAAAA,GAAG,EAAEA,GAJD;AAKJM,QAAAA,WAAW,EAAE;AALT,OAAN;AAOAD,MAAAA,GAAG,CAACS,aAAJ,GAAoBjC,MAAM,CAACa,GAAP,GAAa,KAAKS,IAAL,CAAUH,GAAV,EAAeK,GAAf,EAAoB,KAApB,CAAjC;AACAK,MAAAA,KAAK,GAAG,KAAKhC,MAAb;;AACA,WAAKoB,GAAL,IAAYY,KAAZ,EAAmB;AACjBX,QAAAA,IAAI,GAAGW,KAAK,CAACZ,GAAD,CAAZ;;AACA,YAAIC,IAAI,CAACQ,MAAL,IAAe,IAAnB,EAAyB;AACvBR,UAAAA,IAAI,CAACQ,MAAL,CAAY1B,MAAZ,EAAoBmB,GAAG,CAACF,GAAD,CAAvB,EAA8BO,GAA9B;AACD;AACF;;AACDG,MAAAA,CAAC,GAAG,CAAJ;;AACA,aAAOA,CAAC,GAAGH,GAAG,CAACO,QAAJ,CAAa7B,MAAxB,EAAgC;AAC9B0B,QAAAA,GAAG,GAAGJ,GAAG,CAACO,QAAJ,CAAaJ,CAAC,EAAd,CAAN;AACAC,QAAAA,GAAG,CAACV,IAAJ,CAASQ,MAAT,CAAgB1B,MAAhB,EAAwB4B,GAAG,CAACT,GAA5B,EAAiCS,GAAG,CAAC3B,MAArC;AACD;AACF,KAzBD;;AA2BA,WAAOP,MAAP;AAED,GAnHQ,EAAT;;AAqHAwC,EAAAA,MAAM,CAACC,OAAP,GAAiBzC,MAAjB;AAED,CA5HD,EA4HGc,IA5HH,CA4HQ,IA5HR","sourcesContent":["// Generated by CoffeeScript 1.7.1\n(function() {\n  var Struct, utils;\n\n  utils = require('./utils');\n\n  Struct = (function() {\n    function Struct(fields) {\n      this.fields = fields != null ? fields : {};\n    }\n\n    Struct.prototype.decode = function(stream, parent, length) {\n      var res, _ref;\n      if (length == null) {\n        length = 0;\n      }\n      res = this._setup(stream, parent, length);\n      this._parseFields(stream, res, this.fields);\n      if ((_ref = this.process) != null) {\n        _ref.call(res, stream);\n      }\n      return res;\n    };\n\n    Struct.prototype._setup = function(stream, parent, length) {\n      var res;\n      res = {};\n      Object.defineProperties(res, {\n        parent: {\n          value: parent\n        },\n        _startOffset: {\n          value: stream.pos\n        },\n        _currentOffset: {\n          value: 0,\n          writable: true\n        },\n        _length: {\n          value: length\n        }\n      });\n      return res;\n    };\n\n    Struct.prototype._parseFields = function(stream, res, fields) {\n      var key, type, val;\n      for (key in fields) {\n        type = fields[key];\n        if (typeof type === 'function') {\n          val = type.call(res, res);\n        } else {\n          val = type.decode(stream, res);\n        }\n        if (val !== void 0) {\n          if (val instanceof utils.PropertyDescriptor) {\n            Object.defineProperty(res, key, val);\n          } else {\n            res[key] = val;\n          }\n        }\n        res._currentOffset = stream.pos - res._startOffset;\n      }\n    };\n\n    Struct.prototype.size = function(val, parent, includePointers) {\n      var ctx, key, size, type, _ref;\n      if (val == null) {\n        val = {};\n      }\n      if (includePointers == null) {\n        includePointers = true;\n      }\n      ctx = {\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      size = 0;\n      _ref = this.fields;\n      for (key in _ref) {\n        type = _ref[key];\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n      if (includePointers) {\n        size += ctx.pointerSize;\n      }\n      return size;\n    };\n\n    Struct.prototype.encode = function(stream, val, parent) {\n      var ctx, i, key, ptr, type, _ref, _ref1;\n      if ((_ref = this.preEncode) != null) {\n        _ref.call(val, stream);\n      }\n      ctx = {\n        pointers: [],\n        startOffset: stream.pos,\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n      _ref1 = this.fields;\n      for (key in _ref1) {\n        type = _ref1[key];\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n      i = 0;\n      while (i < ctx.pointers.length) {\n        ptr = ctx.pointers[i++];\n        ptr.type.encode(stream, ptr.val, ptr.parent);\n      }\n    };\n\n    return Struct;\n\n  })();\n\n  module.exports = Struct;\n\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}