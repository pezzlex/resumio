{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _getFactors = _interopRequireDefault(require(\"./getFactors\"));\n\nvar _getDistances = _interopRequireDefault(require(\"./getDistances\"));\n\nvar _advanceWidth = _interopRequireDefault(require(\"../../attributedString/advanceWidth\"));\n/**\n * Adjust run positions by given distances\n *\n * @param {Array} distances\n * @param {Object} line\n * @returns {Object} line\n */\n\n\nvar justifyLine = function justifyLine(distances, line) {\n  var index = 0;\n\n  for (var _iterator = line.runs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var run = _ref;\n\n    for (var _iterator2 = run.positions, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var position = _ref2;\n      position.xAdvance += distances[index++];\n    }\n  }\n\n  return line;\n};\n/**\n * A JustificationEngine is used by a Typesetter to perform line fragment\n * justification. This implementation is based on a description of Apple's\n * justification algorithm from a PDF in the Apple Font Tools package.\n *\n * //TODO: Make it immutable\n *\n * @param {Object} layout options\n * @param {Object} line\n * @returns {Object} line\n */\n\n\nvar justification = function justification(options, line) {\n  var gap = line.box.width - (0, _advanceWidth[\"default\"])(line);\n  if (gap === 0) return; // Exact fit\n\n  var factors = (0, _getFactors[\"default\"])(gap, line, options);\n  var distances = (0, _getDistances[\"default\"])(gap, factors);\n  return justifyLine(distances, line);\n};\n\nvar _default = R.curryN(2, justification);\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/pezannekhambatta/Desktop/resumio/node_modules/@react-pdf/textkit/engines/justification/index.js"],"names":["_interopRequireDefault","require","_interopRequireWildcard","exports","__esModule","R","_getFactors","_getDistances","_advanceWidth","justifyLine","distances","line","index","_iterator","runs","_isArray","Array","isArray","_i","Symbol","iterator","_ref","length","next","done","value","run","_iterator2","positions","_isArray2","_i2","_ref2","position","xAdvance","justification","options","gap","box","width","factors","_default","curryN"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _getFactors = _interopRequireDefault(require(\"./getFactors\"));\n\nvar _getDistances = _interopRequireDefault(require(\"./getDistances\"));\n\nvar _advanceWidth = _interopRequireDefault(require(\"../../attributedString/advanceWidth\"));\n\n/**\n * Adjust run positions by given distances\n *\n * @param {Array} distances\n * @param {Object} line\n * @returns {Object} line\n */\nvar justifyLine = function justifyLine(distances, line) {\n  var index = 0;\n\n  for (var _iterator = line.runs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var run = _ref;\n\n    for (var _iterator2 = run.positions, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var position = _ref2;\n      position.xAdvance += distances[index++];\n    }\n  }\n\n  return line;\n};\n/**\n * A JustificationEngine is used by a Typesetter to perform line fragment\n * justification. This implementation is based on a description of Apple's\n * justification algorithm from a PDF in the Apple Font Tools package.\n *\n * //TODO: Make it immutable\n *\n * @param {Object} layout options\n * @param {Object} line\n * @returns {Object} line\n */\n\n\nvar justification = function justification(options, line) {\n  var gap = line.box.width - (0, _advanceWidth[\"default\"])(line);\n  if (gap === 0) return; // Exact fit\n\n  var factors = (0, _getFactors[\"default\"])(gap, line, options);\n  var distances = (0, _getDistances[\"default\"])(gap, factors);\n  return justifyLine(distances, line);\n};\n\nvar _default = R.curryN(2, justification);\n\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}